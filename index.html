<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Typing Tomes</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/idb@7/build/umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@700&family=Noto+Sans:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&family=Merriweather:wght@400;700&family=Source+Sans+Pro:wght@400;700&display=swap" rel="stylesheet">
	<link rel="icon" type="image/x-icon" href="favicon.ico">
	<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js"></script>
<style>
		/*
		============================================
		THEME DEFINITIONS (CSS VARIABLES)
		============================================
		*/
		:root {
			/* Default Theme Colors */
			--theme-page-bg: #0D131F;
			--theme-ui-bg: #1D2633;
			--theme-untyped: #7C8599;
			--theme-correct: #FDF3A6;
			--theme-incorrect: #F84D6C;
			--theme-cursor-style: underline;
			--theme-ui-bright: #FFFB94;
			--theme-ui-medium: #FC9142;
			--theme-ui-accent: #FFFB94;
		}

		body[data-theme="espresso"] {
			--theme-page-bg: #0F0000;
			--theme-ui-bg: #1F0303;
			--theme-untyped: #B36205;
			--theme-correct: #fde68a;
			--theme-incorrect: #ef4444;
			--theme-cursor-style: underline;
			--theme-ui-bright: #F5D67A;
			--theme-ui-medium: #C75910;
			--theme-ui-accent: #FFA40B;
		}

		body[data-theme="matrix"] {
			--theme-page-bg: #000;
			--theme-ui-bg: #001500;
			--theme-untyped: #018000;
			--theme-correct: #01FF00;
			--theme-incorrect: #f02d2d;
			--theme-cursor-style: block;
			--theme-ui-bright: #01FF00;
			--theme-ui-medium: #05BD00;
			--theme-ui-accent: #07FF00;
		}

		body[data-theme="dracula"] {
			--theme-page-bg: #20222C;
			--theme-ui-bg: #242630;
			--theme-untyped: #6272A4;
			--theme-correct: #F8F8F2;
			--theme-incorrect: #FF5555;
			--theme-cursor-style: underline;
			--theme-ui-bright: #F579CB;
			--theme-ui-medium: #B88FF2;
			--theme-ui-accent: #E3C6FF;
		}
		body[data-theme="monkeytype"] {
			--theme-page-bg: #131314;
			--theme-ui-bg: #232426;
			--theme-untyped: #646669;
			--theme-correct: #EDECE0;
			--theme-incorrect: #CA4754;
			--theme-cursor-style: underline;
			--theme-ui-bright: #FACA16;
			--theme-ui-medium: #C79A00;
			--theme-ui-accent: #FFDF4C;
		}
		body[data-theme="pinkpower"] {
			--theme-page-bg: #FFF0F5;
			--theme-ui-bg: #FFF8FA;
			--theme-untyped: #F2A9CE;
			--theme-correct: #6D214F;
			--theme-incorrect: #DE396A;
			--theme-cursor-style: underline;
			--theme-ui-bright: #FF6EBB;
			--theme-ui-medium: #B33771;
			--theme-ui-accent: #F74CA3;
		}
		body[data-theme="gruvboxdark"] {
			--theme-page-bg: #131314;
			--theme-ui-bg: #232426;
			--theme-untyped: #646669;
			--theme-correct: #FFEEC1;
			--theme-incorrect: #FB4934;
			--theme-cursor-style: underline;
			--theme-ui-bright: #FFE095;
			--theme-ui-medium: #CC8711;
			--theme-ui-accent: #FFC454;
		}
		body[data-theme="ryujin"] {
			--theme-page-bg: #040E1D;
			--theme-ui-bg: #071121;
			--theme-untyped: #946E57;
			--theme-correct: #FFE4BC;
			--theme-incorrect: #C4495B;
			--theme-cursor-style: underline;
			--theme-ui-bright: #FFD0B0;
			--theme-ui-medium: #D4715B;
			--theme-ui-accent: #FFBC90;
		}
		body[data-theme="creamandberries"] {
			--theme-page-bg: #FFFAF4;
			--theme-ui-bg: #FFF8EE;
			--theme-untyped: #EDABEC;
			--theme-correct: #46234D;
			--theme-incorrect: #E85576;
			--theme-cursor-style: underline;
			--theme-ui-bright: #802287;
			--theme-ui-medium: #A32981;
			--theme-ui-accent: #DB3BE8;
		}
		body[data-theme="terminal"] {
			--theme-page-bg: #141516;
			--theme-ui-bg: #191A1B;
			--theme-untyped: #565759;
			--theme-correct: #EFF2E8;
			--theme-incorrect: #A61717;
			--theme-cursor-style: underline;
			--theme-ui-bright: #E6E9DF;
			--theme-ui-medium: #79A617;
			--theme-ui-accent: #ADED21;
		}		
		body[data-theme="olivegarden"] {
			--theme-page-bg: #282E17;
			--theme-ui-bg: #19210F;
			--theme-untyped: #9C591F;
			--theme-correct: #FEFAE0;
			--theme-incorrect: #FB4934;
			--theme-cursor-style: underline;
			--theme-ui-bright: #FEFCCF;
			--theme-ui-medium: #EB872E;
			--theme-ui-accent: #FFCB7A;
		}
		body[data-theme="nonconformist"] {
			--theme-page-bg: #071823;
			--theme-ui-bg: #091F2C;
			--theme-untyped: #8B75BA;
			--theme-correct: #A0FCE6;
			--theme-incorrect: #E45C96;
			--theme-cursor-style: underline;
			--theme-ui-bright: #F5B1CC;
			--theme-ui-medium: #FF64AF;
			--theme-ui-accent: #FFB0CF;
		}
		body[data-theme="boravia"] {
			--theme-page-bg: #12423C;
			--theme-ui-bg: #132229;
			--theme-untyped: #B0553E;
			--theme-correct: #FFDC89;
			--theme-incorrect: #FB4934;
			--theme-cursor-style: underline;
			--theme-ui-bright: #FFBC93;
			--theme-ui-medium: #FC7959;
			--theme-ui-accent: #FFCD98;
		}
		body[data-theme="plumpudding"] {
			--theme-page-bg: #42022E;
			--theme-ui-bg: #21000F;
			--theme-untyped: #8A0E47;
			--theme-correct: #EEF4D4;
			--theme-incorrect: #FB4934;
			--theme-cursor-style: underline;
			--theme-ui-bright: #FFED92;
			--theme-ui-medium: #DBB048;
			--theme-ui-accent: #FFF5B3;
		}
		/*
		============================================
		           THEME APPLICATION
		============================================
		*/
		body { 
			font-family: 'Noto Sans', sans-serif; 
			background: var(--theme-page-bg, var(--theme-default-page-bg));
			min-height: 100vh;
		}

		.untyped { color: var(--untyped-color); }
		.correct { color: var(--correct-color); }
		.incorrect-char { color: var(--theme-incorrect, var(--theme-default-incorrect)); border-bottom-color: var(--theme-incorrect, var(--theme-default-incorrect)); }

		body[data-theme-inversion="false"] {
			--untyped-color: var(--theme-untyped, var(--theme-default-untyped));
			--correct-color: var(--theme-correct, var(--theme-default-correct));
		}
		body[data-theme-inversion="true"] {
			--untyped-color: var(--theme-correct, var(--theme-default-correct));
			--correct-color: var(--theme-untyped, var(--theme-default-untyped));
		}

		/*
		============================================
		     THEME APPLICATION FOR UI ELEMENTS
		============================================
		*/
		.ui-chart-container, .ui-panel-bg, .typing-area-background, .ui-sticky-bar {
			background-color: var(--theme-ui-bg, var(--theme-default-ui-bg));
		}
		.ui-stat-box {
			background-color: var(--theme-page-bg, var(--theme-default-page-bg));
		}
		.ui-stat-label { color: var(--theme-ui-medium, var(--theme-default-ui-medium)); }
		.ui-stat-value, .library-book-card h3, .ui-bright-text, #settings-modal label, .ui-main-title { color: var(--theme-ui-bright, var(--theme-default-ui-bright)); }
		#book-title-header, .ui-accent-text, #analysis-modal .ui-subheading { color: var(--theme-ui-accent, var(--theme-default-ui-accent)); }
		#welcome-message, #chapter-stats, .ui-secondary-text, .library-book-card p { color: var(--theme-ui-medium, var(--theme-default-ui-medium)); }
		.ui-action-button-primary { background-color: var(--theme-ui-accent, var(--theme-default-ui-accent)); color: #111827; }
		.ui-action-button-secondary { background-color: var(--theme-ui-bg, var(--theme-default-ui-bg)); color: var(--theme-ui-bright, var(--theme-default-ui-bright)); border: 1px solid var(--theme-ui-medium, var(--theme-default-ui-medium)); }
		.ui-action-button-danger {
			background-color: var(--theme-incorrect, var(--theme-default-incorrect));
			color: #111827; /* Dark text for contrast */
		}
		kbd { background-color: var(--theme-ui-bg, var(--theme-default-ui-bg)); color: var(--theme-ui-medium, var(--theme-default-ui-medium)); border: 1px solid var(--theme-ui-medium, var(--theme-default-ui-medium)); border-bottom-width: 2px; }
		.ui-bright-text, .ui-main-title { font-family: 'Noto Sans', sans-serif; }
		#file-loader { background-color: var(--theme-ui-bg, var(--theme-default-ui-bg)); }
		.drag-over { border-color: var(--theme-ui-accent, var(--theme-default-ui-accent)); }
		.ui-file-input::file-selector-button { background-color: var(--theme-ui-bg, var(--theme-default-ui-bg)); color: var(--theme-ui-bright, var(--theme-default-ui-bright)); border: 1px solid var(--theme-ui-medium, var(--theme-default-ui-medium)); padding: 0.5rem 1rem; border-radius: 9999px; font-weight: 600; cursor: pointer; margin-right: 1rem; }
		#chapter-selector, #theme-selector { background-color: var(--theme-ui-bg, var(--theme-default-ui-bg)); color: var(--theme-ui-medium, var(--theme-default-ui-medium)); border: 1px solid var(--theme-ui-medium, var(--theme-default-ui-medium)); }
		#settings-modal .choice-btn { background-color: var(--theme-ui-bg, var(--theme-default-ui-bg)); border: 1px solid var(--theme-ui-medium, var(--theme-default-ui-medium)); color: var(--theme-ui-medium, var(--theme-default-ui-medium)); }
		#settings-modal .choice-btn-active { background-color: var(--theme-ui-accent, var(--theme-default-ui-accent)); color: #111827; border-color: transparent; }
		footer.ui-secondary-text a {
			text-decoration: underline;
		}
		footer.ui-secondary-text a:hover {
			color: var(--theme-ui-accent, var(--theme-default-ui-accent));
		}
		.ui-input {
			background-color: var(--theme-ui-bg, var(--theme-default-ui-bg));
			border: 1px solid var(--theme-ui-medium, var(--theme-default-ui-medium));
			color: var(--theme-ui-bright, var(--theme-default-ui-bright));
		}
		#username-input:focus {
			--tw-ring-color: var(--theme-ui-accent, var(--theme-default-ui-accent));
		}
		/*
		============================================
		CURSOR STYLES & GENERAL UI
		============================================
		*/
		@keyframes underline-pulse { 0%, 49% { border-color: #f59e0b; } 50%, 100% { border-color: transparent; } }
		body[data-cursor-style="underline"] .cursor { animation: underline-pulse 1.2s infinite; border-bottom: 3px solid; }
        h1, h3, .chapter-heading { font-family: 'Cormorant Garamond', serif; }
		.chapter-heading { color: var(--theme-ui-bright, var(--theme-default-ui-bright)); border-bottom: 2px solid var(--theme-ui-medium, var(--theme-default-ui-medium)); padding-bottom: 0.5rem; margin-bottom: 2rem; margin-top: 3rem; }
		h2 { font-family: 'Noto Sans', sans-serif; }
        .char-span { transition: color 0.2s, background-color 0.2s, border-color 0.2s; border-radius: 2px; padding-bottom: 2px; border-bottom: 2px solid transparent; }
        .skipped { color: var(--correct-color); }
        .paragraph-block { margin-bottom: 2rem; overflow-wrap: break-word; hyphens: auto; }
        .ui-subheading { font-family: 'Noto Sans', sans-serif; }
        .modal-backdrop { background-color: rgba(0,0,0,0.7); }
        .choice-btn { transition: background-color 0.2s; }
        .choice-btn-active { transform: scale(1.05); }
        .library-book-card { transition: transform 0.2s, box-shadow 0.2s; }
        .library-book-card:hover { transform: translateY(-5px); box-shadow: 0 10px 20px rgba(0,0,0,0.4); }
        .library-book-card img { object-fit: cover; aspect-ratio: 2 / 3; background-color: #374151; }
		.fanfare-char { display: inline-block; animation: color-shift 1.5s infinite; }
		@keyframes color-shift {
			0%, 100% { color: var(--theme-ui-bright, var(--theme-default-ui-bright)); }
			33%      { color: var(--theme-ui-accent, var(--theme-default-ui-accent)); }
			66%      { color: var(--theme-ui-medium, var(--theme-default-ui-medium)); }
		}

		/*
		============================================
		FONT FAMILY AND FONT SIZE RULES
		============================================
		*/
		.font-roboto-mono { font-family: 'Roboto Mono', monospace; }
        .font-lato { font-family: 'Lato', sans-serif; }
        .font-merriweather { font-family: 'Merriweather', serif; }
        .font-noto-sans { font-family: 'Noto Sans', sans-serif; }
        .font-merriweather.font-size-vs { font-size: 1.0rem; line-height: 1.8rem; }
        .font-lato.font-size-vs, .font-noto-sans.font-size-vs { font-size: 1.15rem; line-height: 2.0rem; }
        .font-roboto-mono.font-size-vs { font-size: 1.2rem; line-height: 2.1rem; }
        .font-merriweather.font-size-sm { font-size: 1.25rem; line-height: 2.2rem; }
        .font-lato.font-size-sm, .font-noto-sans.font-size-sm { font-size: 1.4rem; line-height: 2.4rem; }
        .font-roboto-mono.font-size-sm { font-size: 1.5rem; line-height: 2.5rem; }
        .font-merriweather.font-size-md { font-size: 1.5rem; line-height: 2.5rem; }
        .font-lato.font-size-md, .font-noto-sans.font-size-md { font-size: 1.65rem; line-height: 2.7rem; }
        .font-roboto-mono.font-size-md { font-size: 1.8rem; line-height: 2.9rem; }
        .font-merriweather.font-size-lg { font-size: 1.8rem; line-height: 2.9rem; }
        .font-lato.font-size-lg, .font-noto-sans.font-size-lg { font-size: 2.0rem; line-height: 3.1rem; }
        .font-roboto-mono.font-size-lg { font-size: 2.1rem; line-height: 3.2rem; }
        .font-merriweather.font-size-xl { font-size: 2.2rem; line-height: 3.4rem; }
        .font-lato.font-size-xl, .font-noto-sans.font-size-xl { font-size: 2.4rem; line-height: 3.6rem; }
        .font-roboto-mono.font-size-xl { font-size: 2.5rem; line-height: 3.7rem; }

		#typing-app {
		  flex: 1 1 auto;       /* take available space */
		  min-height: 0;        /* allow internal scroll */
		  max-height: 100vh;    /* never bigger than viewport */
		}

		/* The card holding stats + typing area */
		.typing-area-background {
		  flex: 1;
		  min-height: 0;
		  display: flex;
		  flex-direction: column;
		  max-height: calc(100vh - 200px); /* adjust this value */
		}

		/* The actual text container */
		#book-content {
		  flex: 1;
		  min-height: 0;
		  overflow-y: auto;      /* scrolling inside this only */
		}
		.nav-btn-active {
			color: var(--theme-ui-accent, #96F7FF);
		}
		/* Firefox-only: disable blinking cursor */
		@supports (-moz-appearance: none) {
		  .typing-area-background .cursor,
		  #book-content .cursor,
		  #drill-content .cursor {
			animation: none !important;              /* stop the blink */
			border-bottom-color: var(--theme-ui-bright) !important;
		  }
		}


	</style>
</head>
<body class="text-gray-200 flex flex-col items-center min-h-screen p-2 md:p-4">

    <div id="settings-modal" class="fixed inset-0 z-50 flex items-center justify-center modal-backdrop hidden">
        <div class="rounded-lg shadow-xl p-8 w-full max-w-lg ui-panel-bg">
            <h2 class="text-2xl font-bold mb-6 ui-main-title">Typing Settings</h2>
        
            <div class="mb-6">
                <label class="block text-lg font-medium text-gray-300 mb-3">Font Family</label>
                <div id="font-family-selector" class="grid grid-cols-2 sm:grid-cols-4 gap-4">
                    </div>
            </div>

            <div class="mb-8">
                <label class="block text-lg font-medium text-gray-300 mb-3">Font Size</label>
                <div id="font-size-selector" class="grid grid-cols-5 gap-2 sm:gap-4">
                    </div>
            </div>

			<div class="mb-6">
                <label for="theme-selector" class="block text-lg font-medium text-gray-300 mb-3">Theme</label>
                <select id="theme-selector" class="w-full rounded-md p-3"></select>
            </div>

			<div class="mb-8">
				<label class="block text-lg font-medium text-gray-300 mb-3">Typing Colors</label>
				<div id="inversion-selector" class="grid grid-cols-2 gap-4">
					 </div>
			</div>
						<div class="mb-8">
				<label for="daily-goal-input" class="block text-lg font-medium text-gray-300 mb-3">Daily Practice Goal (minutes)</label>
				<input type="number" id="daily-goal-input" min="1" max="300" class="w-full rounded-md p-2 focus:ring-2 focus:outline-none ui-input">
			</div>
        
            <div class="mt-8 flex justify-end">
                <button id="close-settings-btn" class="font-bold py-2 px-4 rounded-md ui-action-button-primary">Done</button>
            </div>
        </div>
    </div>

	<div id="analysis-modal" class="fixed inset-0 z-50 flex items-center justify-center modal-backdrop hidden">
		<div class="rounded-lg shadow-xl p-4 sm:p-8 w-full max-w-2xl max-h-[90vh] flex flex-col ui-panel-bg">
			<h2 class="text-2xl font-bold mb-4 ui-main-title">Your Typing Analysis</h2>
			<p class="mb-6 ui-secondary-text">Here are your slowest letter combinations based on your typing history. Use the drill button to practice them.</p>

			<div class="flex-grow overflow-y-auto pr-4 grid grid-cols-1 md:grid-cols-2 gap-8 min-h-0">
				<div>
					<h3 class="text-lg font-semibold text-indigo-400 mb-3 ui-subheading">Slowest Bigrams (2-Letters)</h3>
					<div id="weak-bigrams-list" class="space-y-2">
						</div>
				</div>
				<div>
					<h3 class="text-lg font-semibold text-indigo-400 mb-3 ui-subheading">Slowest Trigrams (3-Letters)</h3>
					<div id="weak-trigrams-list" class="space-y-2">
						</div>
				</div>
			</div>

			<div class="mt-8 pt-4 border-t border-gray-700 flex justify-between items-center">
				<button id="close-analysis-btn" class="font-bold py-2 px-4 rounded-md ui-action-button-secondary">Close</button>
				<button id="drill-weaknesses-btn" class="font-bold py-2 px-4 rounded-md ui-action-button-primary">Drill My Weaknesses</button>
			</div>
		</div>
	</div>

    <div id="profile-modal" class="fixed inset-0 z-50 flex items-center justify-center modal-backdrop hidden">
        <div class="rounded-lg shadow-xl p-8 w-full max-w-md ui-panel-bg">
            <h2 id="profile-modal-title" class="text-2xl font-bold mb-4 ui-main-title">Create Your Profile</h2>
            <p class="mb-6 ui-secondary-text">Enter a username to save your progress and track your results.</p>
            <div>
                <label for="username-input" class="block text-sm font-medium mb-1 ui-bright-text">Username</label>
                <input type="text" id="username-input" class="w-full rounded-md p-2 focus:ring-2 focus:outline-none ui-input">
            </div>
            <div class="mt-6">
                <button id="save-profile-btn" class="w-full font-bold py-2 px-4 rounded-md ui-action-button-primary">Save and Start</button>
            </div>
        </div>
    </div>

    <div id="profile-switcher-modal" class="fixed inset-0 z-50 flex items-center justify-center modal-backdrop hidden">
        <div class="rounded-lg shadow-xl p-8 w-full max-w-md ui-panel-bg">
            <h2 class="text-2xl font-bold mb-6 ui-main-title">Profile Manager</h2>
            <div id="profile-list-container" class="space-y-3 mb-6 max-h-64 overflow-y-auto">
                </div>
            <div class="pt-4 border-t border-gray-700">
                <button id="show-create-profile-btn" class="w-full font-bold py-2 px-4 rounded-md ui-action-button-primary">Add New Profile</button>
            </div>
        </div>
    </div>
    
	<div id="chapter-selection-modal" class="fixed inset-0 z-50 flex items-center justify-center modal-backdrop hidden">
        <div class="rounded-lg shadow-xl p-8 w-full max-w-2xl max-h-[90vh] flex flex-col ui-panel-bg">
            <h2 class="text-2xl font-bold mb-2 ui-main-title">Select Chapters to Type</h2>
            <p class="mb-6 ui-secondary-text">Choose which sections of the book you want to include in your typing practice.</p>
            <div id="chapter-list-container" class="overflow-y-auto flex-grow pr-4 min-h-0">
                </div>
            <div class="mt-6 pt-4 border-t border-gray-700 flex justify-end space-x-4">
                 <button id="cancel-add-book-btn" class="font-bold py-2 px-4 rounded-md ui-action-button-secondary">Cancel</button>
                <button id="save-chapters-btn" class="font-bold py-2 px-4 rounded-md ui-action-button-primary">Save Book to Library</button>
            </div>
        </div>
    </div>

	<header id="main-nav-bar" class="w-full max-w-5xl mx-auto p-3 rounded-lg items-center justify-between ui-sticky-bar hidden">
        <div class="flex items-center space-x-4">
            <span id="nav-username" class="font-bold ui-bright-text">Hi Albert!</span>
            <button id="nav-change-user-btn" class="text-sm ui-secondary-text">(change)</button>
        </div>
		<div class="flex items-center space-x-6 text-lg">
			<button id="nav-library-btn" class="flex items-center gap-1 font-semibold ui-secondary-text hover:text-[--theme-ui-accent] focus:outline-none">
				<svg xmlns="http://www.w3.org/2000/svg"
					 viewBox="0 0 24 24"
					 class="w-6 h-6 fill-current" aria-hidden="true">
				  <!-- Shelf -->
				  <rect x="2" y="20" width="20" height="2" rx="1"/>

				  <!-- Left upright book (taller) -->
				  <rect x="3" y="4.5" width="4" height="15.5" rx="1"/>
				  <!-- Left book spine bands -->
				  <rect x="3.6" y="8"  width="2.8" height="0.9" rx="0.45"/>
				  <rect x="3.6" y="12" width="2.8" height="0.9" rx="0.45"/>
				  <rect x="3.6" y="16" width="2.8" height="0.9" rx="0.45"/>

				  <!-- Middle upright book (taller) -->
				  <rect x="9" y="3.5" width="4" height="17.5" rx="1"/>
				  <!-- Middle book spine bands -->
				  <rect x="9.6" y="7"  width="2.8" height="0.9" rx="0.45"/>
				  <rect x="9.6" y="11" width="2.8" height="0.9" rx="0.45"/>
				  <rect x="9.6" y="15" width="2.8" height="0.9" rx="0.45"/>
				  <rect x="9.6" y="18" width="2.8" height="0.9" rx="0.45"/>

				  <!-- Right tilted book (unchanged) -->
				  <g transform="rotate(-15 18 12)">
					<rect x="16" y="5" width="4" height="14" rx="1"/>
					<!-- Tilted book spine bands -->
					<rect x="16.6" y="8"  width="2.8" height="0.9" rx="0.45"/>
					<rect x="16.6" y="12" width="2.8" height="0.9" rx="0.45"/>
					<rect x="16.6" y="16" width="2.8" height="0.9" rx="0.45"/>
				  </g>
				</svg>
				<span>Library</span>
			</button>
			<button id="nav-typing-btn" class="flex items-center gap-2 font-semibold ui-secondary-text hover:text-[--theme-ui-accent] focus:outline-none">
				<svg xmlns="http://www.w3.org/2000/svg"
					 viewBox="0 0 24 24"
					 class="w-6 h-6 fill-current">
				  <defs>
					<mask id="kbd-hole">
					  <rect x="0" y="0" width="24" height="24" fill="white"/>
					  <rect x="3.5" y="5.5" width="17" height="13" rx="2.8" ry="2.8" fill="black"/>
					</mask>
				  </defs>
				  <rect x="1.5" y="3.5" width="21" height="17" rx="4" ry="4" mask="url(#kbd-hole)"/>
				  <rect x="6"   y="8.5" width="2" height="2" rx="0.6"/>
				  <rect x="9.5" y="8.5" width="2" height="2" rx="0.6"/>
				  <rect x="13"  y="8.5" width="2" height="2" rx="0.6"/>
				  <rect x="16.5" y="8.5" width="2" height="2" rx="0.6"/>
				  <rect x="6"   y="11.5" width="2" height="2" rx="0.6"/>
				  <rect x="9.5" y="11.5" width="2" height="2" rx="0.6"/>
				  <rect x="13"  y="11.5" width="2" height="2" rx="0.6"/>
				  <rect x="16.5" y="11.5" width="2" height="2" rx="0.6"/>
				  <rect x="7" y="14.5" width="10" height="2" rx="1"/>
				</svg>
				<span>Typing</span>
			</button>
			<button id="nav-reports-btn" class="flex items-center gap-1 font-semibold ui-secondary-text hover:text-[--theme-ui-accent] focus:outline-none">
				<svg xmlns="http://www.w3.org/2000/svg"
					 viewBox="0 0 24 24"
					 class="w-6 h-6 fill-current" aria-hidden="true">
				  <!-- Shortest left bar -->
				  <rect x="4" y="14" width="3" height="5" rx="1"/>
				  <!-- Next bar -->
				  <rect x="9" y="11" width="3" height="8" rx="1"/>
				  <!-- Next bar -->
				  <rect x="14" y="7"  width="3" height="12" rx="1"/>
				  <!-- Tallest bar -->
				  <rect x="19" y="4"  width="3" height="15" rx="1"/>
				</svg>

				<span>Reports</span>
			</button>
			<button id="nav-settings-btn" class="flex items-center gap-1 font-semibold ui-secondary-text hover:text-[--theme-ui-accent] focus:outline-none">
			<svg xmlns="http://www.w3.org/2000/svg" 
				 viewBox="0 0 24 24" 
				 class="w-6 h-6 fill-current">
			  <path d="M19.14 12.94c.04-.31.06-.63.06-.94s-.02-.63-.06-.94l2.03-1.58a.5.5 
					   0 00.11-.65l-1.92-3.32a.5.5 0 00-.61-.22l-2.39.96a7.014 
					   7.014 0 00-1.63-.94l-.36-2.54A.488.488 0 0014.39 2h-4.78c-.24 
					   0-.44.17-.48.41l-.36 2.54c-.59.24-1.14.56-1.63.94l-2.39-.96a.5.5 
					   0 00-.61.22L2.22 8.83c-.14.22-.1.51.11.65l2.03 1.58c-.04.31-.06.63-.06.94 
					   0 .31.02.63.06.94l-2.03 1.58a.5.5 0 00-.11.65l1.92 3.32c.14.22.4.3.61.22l2.39-.96c.49.39 
					   1.04.7 1.63.94l.36 2.54c.04.24.24.41.48.41h4.78c.24 0 .44-.17.48-.41l.36-2.54c.59-.24 
					   1.14-.56 1.63-.94l2.39.96c.22.08.47 0 .61-.22l1.92-3.32a.5.5 0 00-.11-.65l-2.03-1.58zM12 
					   15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 
					   3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"/>
			</svg>

				<span>Settings</span>
			</button>
		</div>
		<div class="relative">
			<button id="nav-book-title-btn" class="flex items-center space-x-2 text-lg font-bold text-right ui-accent-text">
				<span id="nav-book-title"></span>
				<span>▼</span>
			</button>
			<div id="nav-chapter-menu" class="absolute top-full right-0 mt-2 p-2 w-72 rounded-lg shadow-xl ui-panel-bg z-20 hidden">
				</div>
		</div>
    </header>

    <div class="w-full max-w-5xl mx-auto flex-1 flex flex-col min-h-0"> <header id="legacy-header" class="text-center mb-8">
            <h1 id="app-title-header" class="text-5xl md:text-6xl font-bold ui-main-title">Typing Tomes</h1>
			 <h1 id="book-title-header" class="text-5xl md:text-6xl font-bold hidden ui-main-title"></h1>
            <p id="welcome-message" class="text-gray-400 mt-2 hidden ui-secondary-text">Welcome, <span id="username-display" class="font-bold ui-bright-text"></span>!
                <button id="change-user-btn" class="text-sm ui-secondary-text">(Change)</button>
            </p>
        </header>

        <div id="library-view" class="w-full">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-3xl font-bold ui-bright-text">My Library</h2>
                <button id="add-new-book-btn" class="font-bold py-2 px-4 rounded-md ui-action-button-primary">Add New Book</button>
            </div>
            <div id="library-list" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-6">
                </div>
        </div>


		<div id="file-loader" class="p-6 rounded-lg shadow-lg mb-8 hidden ui-panel-bg">
            <h2 class="text-xl font-semibold mb-4 ui-bright-text">Load a Book (.epub)</h2>
			<div id="drop-zone" class="flex flex-col items-center justify-center p-8 border-2 border-dashed border-gray-600 rounded-lg transition-colors">
                 <label for="local-file" class="block text-lg font-medium mb-4 text-center ui-secondary-text">Drag & Drop EPUB file here<br>or click to select</label>
                 <input type="file" id="local-file" accept=".epub" class="block w-full max-w-xs text-sm ui-secondary-text ui-file-input"/>
            </div>
            <div id="loading-status" class="text-center mt-4 text-amber-400"></div>
            <button id="back-to-library-btn" class="mt-4 w-full font-bold py-2 px-4 rounded-md ui-action-button-secondary">Back to Library</button>
        </div>

        <main id="typing-app" class="hidden flex-col">
			<div class="sticky top-0 pb-2 px-4 z-10 ui-sticky-bar">
				<div class="grid grid-cols-2 lg:grid-cols-5 gap-4 text-center">
					<div class="p-4 rounded-lg shadow ui-stat-box">
						<p class="text-sm ui-stat-label">Live WPM</p>
						<div id="live-wpm-display" class="text-3xl font-bold ui-stat-value">0</div>
					</div>
					<div class="p-4 rounded-lg shadow ui-stat-box">
						<p class="text-sm ui-stat-label">Live Accuracy</p>
						<div id="live-accuracy-display" class="text-3xl font-bold ui-stat-value">100%</div>
					</div>
					<div class="p-4 rounded-lg shadow col-span-2 lg:col-span-2 ui-stat-box flex flex-col justify-center space-y-2">
						<div class="flex justify-between items-baseline">
							<p class="text-sm ui-stat-label">Daily Goal</p>
							<div id="daily-goal-text" class="text-lg font-semibold ui-stat-value">0/30 min</div>
						</div>
						<div class="w-full ui-panel-bg rounded-full h-2.5 border-2 border-gray-600">
							<div id="daily-progress-bar" class="bg-amber-400 h-full rounded-full transition-all duration-500" style="width: 0%; background-color: var(--theme-ui-accent, #96F7FF);"></div>
						</div>
					</div>
					<div class="p-4 rounded-lg shadow ui-stat-box">
						<p class="text-sm ui-stat-label">Paragraphs Done</p>
						<div id="paragraph-count" class="text-3xl font-bold ui-stat-value">0 / 0</div>
					</div>
				</div>
			</div>

                <div class="pt-6 px-6 pb-2 rounded-lg shadow-lg relative typing-area-background mt-2">
                     <input type="text" id="hidden-input" style="position: absolute; top: -9999px; left: -9999px; opacity: 0; width: 1px; height: 1px;">
					 <div id="book-content" class="select-none overflow-y-auto focus:outline-none">
                         </div>
                     <div class="text-right text-sm mt-4 ui-bright-text">
                         <span>Press <kbd class="font-bold rounded px-2 py-1 rounded-md text-sm ui-action-button-secondary">Tab</kbd> to restart paragraph.</span>
                         <span>Press <kbd class="font-bold rounded px-2 py-1 rounded-md text-sm ui-action-button-secondary">Enter</kbd> to finish.<span> Press <kbd class="font-bold rounded px-2 py-1 rounded-md text-sm ui-action-button-secondary">Shift+Enter</kbd> to skip.</span><span> Press <kbd class="font-bold rounded px-2 py-1 rounded-md text-sm ui-action-button-secondary">Shift+Tab</kbd> to redo previous.</span></span>
                     </div>
                </div>
		
		</main>
		
		<main id="drill-mode" class="hidden flex-col">
            <div class="py-2 z-10">
                <h2 class="text-3xl font-bold text-center mb-2 ui-main-title">Practice Drill</h2>
				<div class="grid grid-cols-3 gap-4 text-center">
                    <div class="p-2 rounded-lg shadow ui-stat-box">
                        <p class="text-sm ui-stat-label">Drill WPM</p>
                        <div id="drill-wpm-display" class="text-3xl font-bold ui-stat-value">0</div>
                    </div>
                    <div class="p-2 rounded-lg shadow ui-stat-box">
                        <p class="text-sm ui-stat-label">Drill Accuracy</p>
                        <div id="drill-accuracy-display" class="text-3xl font-bold ui-stat-value">100%</div>
                    </div>
                    <div class="p-2 rounded-lg shadow ui-stat-box">
                        <p class="text-sm ui-stat-label">Words Typed</p>
                        <div id="drill-word-count" class="text-3xl font-bold ui-stat-value">0 / 50</div>
                    </div>
                </div>
            </div>
    
            <div class="mt-2 p-4 rounded-lg shadow-lg relative typing-area-background">
                <div id="drill-content" class="select-none overflow-y-auto text-3xl leading-loose focus:outline-none" tabindex="-1">
                </div>
            </div>
    
            <div class="mt-8 flex justify-between items-center">
                <button id="end-drill-btn" class="font-bold py-2 px-4 rounded-md ui-action-button-secondary">End Drill</button>
                <button id="drill-more-btn" class="font-bold py-2 px-4 rounded-md ui-action-button-primary">Drill More Words</button>
            </div>
        </main>
		
		<main id="reports-view" class="hidden flex-col">
				<div class="p-6 rounded-lg shadow-lg ui-chart-container">
					<div class="flex justify-between items-center mb-4">
						<button id="chart-toggle-btn" class="font-bold py-2 px-4 rounded-md text-sm ui-action-button-secondary">Show Entire Book</button>
						<h3 class="text-xl font-semibold ui-bright-text text-center">Performance History</h3>
						<button id="full-report-btn" class="font-bold py-2 px-4 rounded-md text-sm ui-action-button-primary">Full Report</button>
					</div>

					<div id="history-chart-container">
						<canvas id="history-chart"></canvas>
					</div>
					<div id="full-report-view" class="hidden">
						<div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-center mb-6">
							<div class="p-3 rounded-lg ui-stat-box">
								<p class="text-sm ui-stat-label">Current Streak</p>
								<div id="stats-current-streak" class="text-2xl font-bold ui-stat-value">--</div>
							</div>
							<div class="p-3 rounded-lg ui-stat-box">
								<p class="text-sm ui-stat-label">Longest Streak</p>
								<div id="stats-longest-streak" class="text-2xl font-bold ui-stat-value">--</div>
							</div>
							<div class="p-3 rounded-lg ui-stat-box">
								<p class="text-sm ui-stat-label">Avg WPM (Last 30d)</p>
								<div id="stats-avg-wpm" class="text-2xl font-bold ui-stat-value">--</div>
							</div>
							<div class="p-3 rounded-lg ui-stat-box">
								<p class="text-sm ui-stat-label">Avg Acc (Last 30d)</p>
								<div id="stats-avg-acc" class="text-2xl font-bold ui-stat-value">--%</div>
							</div>
						</div>
						
						<div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-center mb-6">
							<div class="p-3 rounded-lg ui-stat-box">
								<p class="text-xs ui-stat-label">Time Practiced (Last 30d)</p>
								<div id="report-stats-time-30d" class="text-2xl font-bold ui-stat-value">--</div>
							</div>
							<div class="p-3 rounded-lg ui-stat-box">
								<p class="text-xs ui-stat-label">Words Typed (Last 30d)</p>
								<div id="report-stats-words-30d" class="text-2xl font-bold ui-stat-value">--</div>
							</div>
							<div class="p-3 rounded-lg ui-stat-box">
								<p class="text-xs ui-stat-label">Time Practiced (All Time)</p>
								<div id="report-stats-time-all" class="text-2xl font-bold ui-stat-value">--</div>
							</div>
							<div class="p-3 rounded-lg ui-stat-box">
								<p class="text-xs ui-stat-label">Words Typed (All Time)</p>
								<div id="report-stats-words-all" class="text-2xl font-bold ui-stat-value">--</div>
							</div>
						</div>

						<div class="grid grid-cols-1 gap-8 mt-8">
							<div>
								<h4 class="text-lg font-semibold ui-bright-text mb-3 text-center">Daily Activity</h4>
								<div id="heatmap-months-container" class="flex justify-between text-xs ui-secondary-text mb-1 px-1"></div>
								<div id="heatmap-container" class="w-full"></div>
							</div>
							<div>
								<h4 class="text-lg font-semibold ui-bright-text mb-3 text-center">WPM Trend</h4>
								<canvas id="wpm-trend-chart"></canvas>
							</div>
						</div>
					</div>
				</div>

			<div class="mt-4 flex justify-center items-center">
				<button id="analysis-btn" class="font-bold py-2 px-4 rounded-md ui-action-button-primary">Analysis and Drills</button>
			</div>
			</div>

            </main>

    </div>

	<footer id="main-footer" class="text-center py-8 text-sm ui-secondary-text">
        <a href="https://asilver.github.io/Typing_Tomes/" target="_blank" rel="noopener noreferrer" 
       class="hover:text-indigo-400 transition-colors">
        View on GitHub
        </a>
        <span class="mx-2">|</span>
        <span>
        Released under the <a href="https://github.com/asilver/Typing_Tomes/blob/main/LICENSE" target="_blank" rel="noopener noreferrer" class="underline hover:text-indigo-400 transition-colors">MIT License</a>.
        </span>
    </footer>

    <script>
        // DOM Elements
		const drillModeSection = document.getElementById('drill-mode');
		const drillContentEl = document.getElementById('drill-content');
		const drillWpmDisplay = document.getElementById('drill-wpm-display');
		const drillAccuracyDisplay = document.getElementById('drill-accuracy-display');
		const drillWordCount = document.getElementById('drill-word-count');
		const endDrillBtn = document.getElementById('end-drill-btn');
		const drillMoreBtn = document.getElementById('drill-more-btn');
		const analysisModal = document.getElementById('analysis-modal');
		const analysisBtn = document.getElementById('analysis-btn');
		const closeAnalysisBtn = document.getElementById('close-analysis-btn');
		const drillWeaknessesBtn = document.getElementById('drill-weaknesses-btn');
		const weakBigramsList = document.getElementById('weak-bigrams-list');
		const weakTrigramsList = document.getElementById('weak-trigrams-list');
        const libraryView = document.getElementById('library-view');
        const libraryList = document.getElementById('library-list');
        const addNewBookBtn = document.getElementById('add-new-book-btn');
        const fileLoaderSection = document.getElementById('file-loader');
        const backToLibraryBtn = document.getElementById('back-to-library-btn');
        const exitToLibraryBtn = document.getElementById('exit-to-library-btn');
        const typingAppSection = document.getElementById('typing-app');
        const localFileInput = document.getElementById('local-file');
        const loadingStatus = document.getElementById('loading-status');
        const dropZone = document.getElementById('drop-zone');
        const settingsModal = document.getElementById('settings-modal');
        const settingsBtn = document.getElementById('settings-btn');
        const closeSettingsBtn = document.getElementById('close-settings-btn');
        const fontFamilySelector = document.getElementById('font-family-selector');
        const fontSizeSelector = document.getElementById('font-size-selector');
		const mainNavBar = document.getElementById('main-nav-bar');
        const reportsView = document.getElementById('reports-view');
        const navUsername = document.getElementById('nav-username');
        const navChangeUserBtn = document.getElementById('nav-change-user-btn');
        const navLibraryBtn = document.getElementById('nav-library-btn');
        const navReportsBtn = document.getElementById('nav-reports-btn');
        const navSettingsBtn = document.getElementById('nav-settings-btn');
        const navBookTitle = document.getElementById('nav-book-title');
		const navBookTitleBtn = document.getElementById('nav-book-title-btn');
		const navChapterMenu = document.getElementById('nav-chapter-menu');
		const mainFooter = document.getElementById('main-footer');
		const legacyHeader = document.getElementById('legacy-header');
		const navTypingBtn = document.getElementById('nav-typing-btn');

        // --- MASTER LISTS FOR ADAPTIVE TRAINING (with thanks to Monkeytype) ---

        // Top 2000 most common English words (2-10 letters long)
		const MASTER_WORDS_2K = ["the", "of", "to", "and", "in", "is", "it", "you", "that", "he", "was", "for", "on", "are", "with", "as", "his", "they", "be", "at", "one", "have", "this", "from", "or", "had", "by", "not", "word", "but", "what", "some", "we", "can", "out", "other", "were", "all", "there", "when", "up", "use", "your", "how", "said", "an", "each", "she", "which", "do", "their", "time", "if", "will", "way", "about", "many", "then", "them", "write", "would", "like", "so", "these", "her", "long", "make", "thing", "see", "him", "two", "has", "look", "more", "day", "could", "go", "come", "did", "number", "sound", "no", "most", "people", "my", "over", "know", "water", "than", "call", "first", "who", "may", "down", "side", "been", "now", "find", "any", "new", "work", "part", "take", "get", "place", "made", "live", "where", "after", "back", "little", "only", "round", "man", "year", "came", "show", "every", "good", "me", "give", "our", "under", "name", "very", "through", "just", "form", "sentence", "great", "think", "say", "help", "low", "line", "differ", "turn", "cause", "much", "mean", "before", "move", "right", "boy", "old", "too", "same", "tell", "does", "set", "three", "want", "air", "well", "also", "play", "small", "end", "put", "home", "read", "hand", "port", "large", "spell", "add", "even", "land", "here", "must", "big", "high", "such", "follow", "act", "why", "ask", "men", "change", "went", "light", "kind", "off", "need", "house", "picture", "try", "us", "again", "animal", "point", "mother", "world", "near", "build", "self", "earth", "father", "head", "stand", "own", "page", "should", "country", "found", "answer", "school", "grow", "study", "still", "learn", "plant", "cover", "food", "sun", "four", "between", "state", "keep", "eye", "never", "last", "let", "thought", "city", "tree", "cross", "farm", "hard", "start", "might", "story", "saw", "far", "sea", "draw", "left", "late", "run", "while", "press", "close", "night", "real", "life", "few", "north", "open", "seem", "together", "next", "white", "children", "begin", "got", "walk", "example", "ease", "paper", "group", "always", "music", "those", "both", "mark", "often", "letter", "until", "mile", "river", "car", "feet", "care", "second", "book", "carry", "took", "science", "eat", "room", "friend", "began", "idea", "fish", "mountain", "stop", "once", "base", "hear", "horse", "cut", "sure", "watch", "color", "face", "wood", "main", "enough", "plain", "girl", "usual", "young", "ready", "above", "ever", "red", "list", "though", "feel", "talk", "bird", "soon", "body", "dog", "family", "direct", "pose", "leave", "song", "measure", "door", "product", "black", "short", "numeral", "class", "wind", "question", "happen", "complete", "ship", "area", "half", "rock", "order", "fire", "south", "problem", "piece", "told", "knew", "pass", "since", "top", "whole", "king", "space", "heard", "best", "hour", "better", "true", "during", "hundred", "five", "remember", "step", "early", "hold", "west", "ground", "interest", "reach", "fast", "verb", "sing", "listen", "six", "table", "travel", "less", "morning", "ten", "simple", "several", "vowel", "toward", "war", "lay", "against", "pattern", "slow", "center", "love", "person", "money", "serve", "appear", "road", "map", "rain", "rule", "govern", "pull", "cold", "notice", "voice", "unit", "power", "town", "fine", "certain", "fly", "fall", "lead", "cry", "dark", "machine", "note", "wait", "plan", "figure", "star", "box", "noun", "field", "rest", "correct", "able", "pound", "done", "beauty", "drive", "stood", "contain", "front", "teach", "week", "final", "gave", "green", "oh", "quick", "develop", "ocean", "warm", "free", "minute", "strong", "special", "mind", "behind", "clear", "tail", "produce", "fact", "street", "inch", "multiply", "nothing", "course", "stay", "wheel", "full", "force", "blue", "object", "decide", "surface", "deep", "moon", "island", "foot", "system", "busy", "test", "record", "boat", "common", "gold", "possible", "plane", "stead", "dry", "wonder", "laugh", "thousand", "ago", "ran", "check", "game", "shape", "equate", "hot", "miss", "brought", "heat", "snow", "tire", "bring", "yes", "distant", "fill", "east", "paint", "language", "among", "grand", "ball", "yet", "wave", "drop", "heart", "am", "present", "heavy", "dance", "engine", "position", "arm", "wide", "sail", "material", "size", "vary", "settle", "speak", "weight", "general", "ice", "matter", "circle", "pair", "include", "divide", "syllable", "felt", "perhaps", "pick", "sudden", "count", "square", "reason", "length", "represent", "art", "subject", "region", "energy", "hunt", "probable", "bed", "brother", "egg", "ride", "cell", "believe", "fraction", "forest", "sit", "race", "window", "store", "summer", "train", "sleep", "prove", "lone", "leg", "exercise", "wall", "catch", "mount", "wish", "sky", "board", "joy", "winter", "sat", "written", "wild", "kept", "glass", "grass", "cow", "job", "edge", "sign", "visit", "past", "soft", "fun", "bright", "gas", "weather", "month", "million", "bear", "finish", "happy", "hope", "flower", "clothes", "strange", "gone", "jump", "baby", "eight", "village", "meet", "root", "buy", "raise", "solve", "metal", "whether", "push", "seven", "third", "shall", "held", "hair", "describe", "cook", "floor", "either", "result", "burn", "hill", "safe", "cat", "century", "consider", "type", "law", "bit", "coast", "copy", "phrase", "silent", "tall", "sand", "soil", "roll", "temperature", "finger", "industry", "value", "fight", "lie", "beat", "excite", "natural", "sense", "ear", "else", "quite", "broke", "case", "middle", "kill", "son", "lake", "moment", "scale", "loud", "observe", "child", "straight", "consonant", "nation", "milk", "speed", "method", "organ", "pay", "age", "section", "dress", "cloud", "surprise", "quiet", "tiny", "climb", "cool", "poor", "lot", "experiment", "bottom", "key", "iron", "single", "stick", "flat", "twenty", "skin", "smile", "crease", "hole", "trade", "melody", "trip", "office", "receive", "row", "mouth", "exact", "symbol", "die", "least", "trouble", "shout", "except", "wrote", "seed", "tone", "join", "suggest", "clean", "break", "lady", "yard", "rise", "bad", "blow", "oil", "blood", "touch", "grew", "cent", "mix", "team", "wire", "cost", "lost", "brown", "wear", "garden", "equal", "sent", "choose", "fell", "fit", "flow", "fair", "bank", "collect", "save", "control", "gentle", "woman", "captain", "practice", "separate", "difficult", "doctor", "please", "protect", "noon", "whose", "locate", "caught", "period", "spoke", "atom", "electric", "expect", "crop", "element", "hit", "student", "party", "bone", "rail", "imagine", "provide", "agree", "thus", "capital", "chair", "danger", "fruit", "rich", "thick", "soldier", "operate", "guess", "sharp", "wing", "create", "neighbor", "wash", "bat", "rather", "crowd", "compare", "depend", "meat", "rub", "tube", "famous", "dollar", "stream", "fear", "thin", "planet", "hurry", "chief", "colony", "clock", "mine", "tie", "major", "fresh", "yellow", "gun", "allow", "dead", "spot", "desert", "suit", "lift", "rose", "continue", "hat", "sell", "success", "company", "subtract", "particular", "deal", "swim", "term", "opposite", "wife", "shoulder", "spread", "invent", "cotton", "born", "determine", "quart", "nine", "truck", "noise", "level", "chance", "gather", "shop", "stretch", "throw", "shine", "property", "column", "molecule", "select", "wrong", "gray", "repeat", "require", "broad", "prepare", "salt", "nose", "plural", "claim", "continent", "oxygen", "sugar", "death", "pretty", "skill", "season", "solution", "magnet", "silver", "thank", "branch", "match", "suffix", "especially", "huge", "sister", "steel", "discuss", "forward", "similar", "guide", "bought", "led", "coat", "mass", "card", "rope", "slip", "win", "dream", "evening", "feed", "tool", "basic", "smell", "nor", "seat", "arrive", "master", "parent", "shore", "sheet", "substance", "favor", "connect", "spend", "chord", "fat", "glad", "original", "share", "dad", "bread", "charge", "proper", "offer", "segment", "duck", "instant", "degree", "populate", "chick", "dear", "enemy", "reply", "drink", "occur", "speech", "steam", "motion", "liquid", "meant", "quotient", "shell", "neck", "public", "universe", "web", "services", "click", "service", "date", "email", "health", "policy", "available", "copyright", "info", "privacy", "items", "research", "mail", "management", "united", "hotel", "comments", "member", "because", "local", "using", "education", "national", "posted", "internet", "address", "community", "within", "phone", "shipping", "reserved", "code", "index", "being", "file", "link", "today", "technology", "project", "sports", "related", "security", "county", "photo", "network", "following", "download", "without", "per", "access", "resources", "posts", "media", "pictures", "personal", "including", "directory", "board", "location", "rating", "government", "return", "students", "shopping", "account", "sites", "digital", "profile", "previous", "events", "image", "another", "shall", "customer", "movies", "include", "college", "article", "jobs", "author", "sale", "around", "teen", "stock", "training", "credit", "advanced", "estate", "gay", "thread", "register", "however", "really", "action", "series", "model", "features", "human", "provided", "yes", "required", "forums", "march", "better", "questions", "going", "medical", "server", "cart", "staff", "articles", "feedback", "looking", "never", "street", "topic", "comment", "things", "working", "against", "standard", "tax", "below", "mobile", "got", "blog", "payment", "login", "offers", "legal", "above", "recent", "park", "memory", "social", "quote", "options", "rates", "important", "single", "something", "Texas", "poker", "status", "browse", "issue", "range", "building", "seller", "court", "audio", "given", "release", "request", "fax", "making", "needs", "might", "future", "become", "learning", "delivery", "popular", "welcome", "central", "notice", "god", "radio", "council", "away", "includes", "track", "archive", "further", "updated", "having", "provides", "already", "studies", "specific", "living", "arts", "powered", "means", "director", "daily", "beach", "planning", "says", "official", "weather", "technical", "pro", "update", "early", "miles", "ago", "written", "federal", "adult", "tickets", "cheap", "kids", "finance", "reading", "topics", "plus", "auto", "percent", "global", "tech", "meet", "economic", "player", "lyrics", "subscribe", "submit", "amount", "watch", "included", "risk", "thanks", "deals", "various", "weight", "received", "camera", "golf", "domain", "makes", "taken", "annual", "shows", "corporate", "purchase", "hardware", "holiday", "death", "brand", "discount", "higher", "created", "political", "kingdom", "near", "doing", "shoes", "entry", "summary", "agency", "drug", "western", "income", "cash", "package", "album", "started", "double", "soon", "across", "benefits", "needed", "apply", "someone", "held", "anything", "anyone", "mature", "addition", "lower", "union", "jewelry", "homepage", "gas", "skills", "six", "bush", "career", "rental", "taking", "values", "coming", "logo", "actually", "nice", "score", "client", "sample", "shown", "culture", "flash", "starting", "consumer", "airport", "foreign", "artist", "outside", "levels", "channel", "mode", "phones", "ideas", "fund", "summer", "allow", "degree", "contract", "button", "wed", "homes", "super", "male", "custom", "almost", "took", "located", "multiple", "inn", "cause", "focus", "late", "fall", "rooms", "female", "primary", "cancer", "browser", "friendly", "police", "physical", "unique", "survey", "prior", "regular", "secure", "favorite", "built", "improve", "larger", "impact", "owners", "disease", "paid", "perfect", "basis", "award", "distance", "extra", "budget", "rated", "guides", "maximum", "quite", "rated", "guides", "success", "maximum", "existing", "quite", "boy", "wine", "horse", "vote", "forward", "flowers", "stars", "owner", "retail", "useful", "directly", "ways", "son", "providing", "rule", "housing", "takes", "bring", "catalog", "trying", "mother", "told", "traffic", "joined", "input", "feet", "agent", "valid", "bin", "modern", "senior", "teaching", "door", "grand", "testing", "trial", "charge", "units", "instead", "cool", "normal", "wrote", "ships", "entire", "metal", "positive", "fitness", "opinion", "football", "abstract", "uses", "output", "funds", "greater", "likely", "develop", "guest", "seems", "pass", "trust", "van", "session", "multi", "fees", "century", "skin", "ads", "expected", "ring", "grade", "dating", "pacific", "mountain", "pop", "filter", "mailing", "vehicle", "longer", "consider", "northern", "behind", "panel", "floor", "buying", "match", "proposed", "default", "require", "boys", "outdoor", "deep", "morning", "allows", "rest", "protein", "plant", "reported", "hit", "pool", "politics", "partner", "authors", "boards", "faculty", "parties", "fish", "eye", "string", "sense", "pack", "released", "stage", "internal", "goods", "born", "unless", "detailed", "race", "approved", "target", "except", "maybe", "moving", "brands", "places", "pretty", "southern", "winter", "battery", "youth", "pressure", "debt", "medium", "core", "break", "sets", "dance", "wood", "itself", "defined", "papers", "playing", "awards", "fee", "studio", "reader", "virtual", "device", "answers", "rent", "remote", "dark", "external", "apple", "enjoy", "remove", "aid", "surface", "minimum", "visual", "host", "variety", "manual", "block", "agents", "repair", "fair", "civil", "steel", "songs", "fixed", "wrong", "beginning", "hands", "finally", "updates", "desktop", "gets", "sector", "fully", "father", "electric", "saw", "quotes", "officer", "driver", "dead", "respect", "unknown", "trip", "worth", "poor", "teacher", "eyes", "workers", "farm", "peace", "campus", "showing", "creative", "coast", "benefit", "progress", "funding", "lord", "grant", "agree", "fiction", "hear", "sometimes", "goes", "families", "led", "museum", "fan", "transport", "wife", "ten", "hits", "zone", "complex", "cat", "die", "flat", "flow", "parent", "setting", "scale", "stand", "economy", "highest", "helpful", "monthly", "critical", "frame", "musical", "path", "employee", "chief", "gives", "bottom", "detail", "laws", "changed", "pet", "heard", "begin", "royal", "clean", "switch", "largest", "guy", "titles", "relevant", "justice", "connect", "bible", "cup", "basket", "applied", "weekly", "suite", "square", "advance", "skip", "diet", "army", "auction", "gear", "lee", "allowed", "correct", "nation", "selling", "lots", "piece", "sheet", "firm", "seven", "older", "jump", "cells", "module", "resort", "random", "pricing", "looks", "fashion", "visitors", "monitor", "trading", "forest", "calls", "whose", "couple", "giving", "chance", "vision", "ball", "ending", "clients", "actions", "listen", "discuss", "accept", "goal", "sold", "wind", "clinical", "lowest", "highly", "appear", "lives", "currency", "leather", "palm", "patient", "actual", "stone", "commerce", "perhaps", "persons", "fit", "tests", "village", "amateur", "met", "pain", "factors", "coffee", "buyer", "cultural", "easily", "oral", "ford", "poster", "edge", "root", "closed", "holidays", "ice", "pink", "balance", "shot", "initial", "label", "thinking", "league", "waste", "minute", "bus", "optional", "cold", "chair", "fishing", "effort", "phase", "fields", "bag", "fantasy", "letters", "motor", "context", "install", "shirt", "foot", "mass", "crime", "count", "quickly", "dollars", "religion", "claim", "driving", "surgery", "patch", "heat", "wild", "generation", "miss", "chemical", "doctor", "task", "reduce", "brought", "himself", "nor", "enable", "exercise", "bug", "santa", "leader", "diamond", "soft", "servers", "alone", "seconds", "keyword", "flight", "congress", "fuel", "username", "walk", "produced", "wait", "pocket", "saint", "rose", "freedom", "creating", "drugs", "joint", "premium", "fresh", "attorney", "upgrade", "factor", "growing", "stream", "pick", "hearing", "eastern", "therapy", "entries", "dates", "signed", "upper", "serious", "prime", "limit", "began", "steps", "errors", "shops", "bondage", "efforts", "informed", "creek", "worked", "quantity", "urban", "sorted", "myself", "tours", "platform", "load", "affiliate", "labor", "admin", "nursing", "defense", "heavy", "covered", "recovery", "guys", "merchant", "expert", "protect", "drop", "solid", "became", "orange", "prevent", "theme", "rich", "campaign", "marine", "guitar", "finding", "saying", "spirit", "challenge", "acceptance", "strategies", "affairs", "intended", "hire", "election", "magic", "smart", "talking", "gave", "ones", "latin", "multimedia", "avoid", "certified", "manage", "rank", "computing", "birth", "virus", "abuse", "quarter", "procedure", "leadership", "define", "racing", "religious", "breakfast", "faith", "chain", "developer", "identify", "avenue", "missing", "died", "domestic", "moved", "comparison", "mental", "viewed", "extended", "sequence", "attack", "sorry", "opening", "damage", "reserve", "recipes", "gamma", "plastic", "placed", "truth", "counter", "failure", "weekend", "bridge", "native", "movement", "printing", "baseball", "owned", "approval", "draft", "played", "adventure", "matching", "offering", "profit", "assistant", "variable", "parking", "headlines"];

        // Top 200 most common English bigrams (letter pairs)
        const MASTER_BIGRAMS_200 = ["th", "he", "in", "er", "an", "re", "on", "at", "en", "nd", "ti", "es", "or", "te", "of", "ed", "is", "it", "al", "ar", "st", "to", "nt", "ng", "se", "ha", "as", "ou", "io", "le", "ve", "co", "me", "de", "hi", "ri", "ro", "ic", "ne", "ea", "ra", "ce", "li", "ch", "ll", "be", "ma", "si", "om", "ur", "ca", "el", "ta", "la", "ns", "di", "fo", "ho", "pe", "ec", "pr", "no", "ct", "us", "ac", "ot", "il", "tr", "ly", "nc", "et", "ut", "ss", "so", "rs", "un", "lo", "wa", "ge", "ie", "wh", "ee", "wi", "em", "ad", "ol", "rt", "po", "we", "na", "ul", "ni", "ts", "mo", "ow", "pa", "im", "mi", "ai", "sh", "ir", "su", "id", "os", "iv", "ia", "am", "fi", "ci", "vi", "pl", "ig", "tu", "ev", "ld", "ry", "mp", "fe", "bl", "ab", "gh", "ty", "op", "wo", "sa", "ay", "ex", "ke", "fr", "oo", "av", "ag", "if", "ap", "gr", "od", "bo", "sp", "rd", "do", "uc", "bu", "ei", "ov", "by", "rm", "ep", "tt", "oc", "fa", "ef", "cu", "rn", "sc", "gi", "da", "yo", "cr", "cl", "du", "ga", "qu", "ue", "ff", "ba", "ey", "ls", "va", "um", "pp", "ua", "up", "lu", "go", "ht", "ru", "ug", "ds", "lt", "pi", "rc", "rr", "eg", "au", "ck", "ew", "mu", "br", "bi", "pt", "ak", "pu", "ui", "rg", "ib", "tl", "ny", "ki", "rk", "ys", "ob", "mm", "fu", "ph", "og", "ms", "ye", "ud", "mb", "ip", "ub", "oi", "rl", "gu", "dr", "hr", "cc", "tw", "ft", "wn", "nu", "af", "hu", "nn", "eo", "vo", "rv", "nf", "xp", "gn", "sm", "fl", "iz", "ok", "nl", "my", "gl", "aw", "ju", "oa", "eq", "sy", "sl", "ps", "jo", "lf", "nv", "je", "nk", "kn"];

        // Top 200 most common English trigrams (letter triplets)
        const MASTER_TRIGRAMS_200 = ["the", "and", "ing", "ion", "tio", "ent", "ati", "for", "her", "ter", "hat", "tha", "ere", "ate", "his", "con", "res", "ver", "all", "ons", "nce", "men", "ith", "ted", "ers", "pro", "thi", "wit", "are", "ess", "not", "ive", "was", "ect", "rea", "com", "eve", "per", "int", "est", "sta", "cti", "ica", "ist", "ear", "ain", "one", "our", "iti", "rat", "nte", "tin", "ine", "der", "ome", "man", "pre", "rom", "tra", "whi", "ave", "str", "act", "ill", "ure", "ide", "ove", "cal", "ble", "out", "sti", "tic", "oun", "enc", "ore", "ant", "ity", "fro", "art", "tur", "par", "red", "oth", "eri", "hic", "ies", "ste", "ght", "ich", "igh", "und", "you", "ort", "era", "wer", "nti", "oul", "nde", "ind", "tho", "hou", "nal", "but", "hav", "uld", "use", "han", "hin", "een", "ces", "cou", "lat", "tor", "ese", "age", "ame", "rin", "anc", "ten", "hen", "min", "eas", "can", "lit", "cha", "ous", "eat", "end", "ssi", "ial", "les", "ren", "tiv", "nts", "whe", "tat", "abl", "dis", "ran", "wor", "rou", "lin", "had", "sed", "ont", "ple", "ugh", "inc", "sio", "din", "ral", "ust", "tan", "nat", "ins", "ass", "pla", "ven", "ell", "she", "ose", "ite", "lly", "rec", "lan", "ard", "hey", "rie", "pos", "eme", "mor", "den", "oug", "tte", "ned", "rit", "ime", "sin", "ast", "any", "orm", "ndi", "ona", "spe", "ene", "hei", "ric", "ice", "ord", "omp", "nes", "sen", "tim", "tri", "ern", "tes", "por", "app", "lar", "ntr", "eir", "sho", "son", "cat", "lle", "ner", "hes", "who", "mat", "ase", "kin", "ost", "ber", "its", "nin", "lea", "ina", "mpl", "sto", "ari", "pri", "own", "ali", "ree", "ish", "des", "ead", "nst", "sit", "ses", "ans", "has", "gre", "ong", "als", "fic", "ual", "ien", "gen", "ser", "unt", "eco", "nta", "ace", "chi", "fer", "tal", "low", "ach", "ire"];

        // Add these new constants for the settings options
        const FONT_OPTIONS = {
            'roboto-mono': 'Roboto Mono',
            'lato': 'Lato',
            'merriweather': 'Merri weather',
            'noto-sans': 'Noto Sans'
        };
        const FONT_SIZES = {
            'vs': 'V. Small',
            'sm': 'Small',
            'md': 'Medium',
            'lg': 'Large',
            'xl': 'X-Large'
        };
		
        const appTitleHeader = document.getElementById('app-title-header');
        const bookTitleHeader = document.getElementById('book-title-header');
		const bookContentEl = document.getElementById('book-content');
		const hiddenInput = document.getElementById('hidden-input');
		let currentContentEl = bookContentEl; // This will track the active typing area
        const liveWpmDisplay = document.getElementById('live-wpm-display');
        const liveAccuracyDisplay = document.getElementById('live-accuracy-display');
        const paragraphCountDisplay = document.getElementById('paragraph-count');
        const chartToggleButton = document.getElementById('chart-toggle-btn');
        
        // Profile Modal Elements
        const profileModal = document.getElementById('profile-modal');
        const profileModalTitle = document.getElementById('profile-modal-title');
        const usernameInput = document.getElementById('username-input');
        const saveProfileBtn = document.getElementById('save-profile-btn');
        const usernameDisplay = document.getElementById('username-display');
        const welcomeMessage = document.getElementById('welcome-message');
        const changeUserBtn = document.getElementById('change-user-btn');
        const deleteUserBtn = document.getElementById('delete-user-btn');

        // Profile Switcher Elements
        const profileSwitcherModal = document.getElementById('profile-switcher-modal');
        const profileListContainer = document.getElementById('profile-list-container');
        const showCreateProfileBtn = document.getElementById('show-create-profile-btn');
        const cancelCreateProfileBtn = document.getElementById('cancel-create-profile-btn'); // may be null

        // Chapter Selection Modal Elements
        const chapterSelectionModal = document.getElementById('chapter-selection-modal');
        const chapterListContainer = document.getElementById('chapter-list-container');
        const saveChaptersBtn = document.getElementById('save-chapters-btn');
        const cancelAddBookBtn = document.getElementById('cancel-add-book-btn');

        // App State
        const CHARS_PER_WORD = 5;
		const DB_NAME = 'TypingTomesDB';
		const DB_VERSION = 1;     
		const STORE_NAME = 'books';
        let currentUsername = '';
		let currentParagraphAnalysis = {};
        let currentBookIdentifier = '';
        let fullBookText = '';
        let chapterMarkers = [];
        let currentChapterIndex = -1;
        let currentChapterWordCount = 0; 
		let isDrillActive = false;
		let drillTargetLength = 0;
		let drillTotalWords = 0;
        
        let currentChapterParagraphs = [];
        let currentParagraphIndexInChapter = -1;
        
        let currentUserInput = '';
        let isTestActive = false;
        let isBookLoading = false;
		let currentParagraphSpans = [];
		let currentCursorSpan = null;
		let paragraphStartTime = 0;
		let dailyProgressTimer = null;
		let secondsPracticedToday = 0;
		let isUpdateScheduled = false;
        
        // Temporary state for book being added
        let tempBookData = {};
        
        // Live WPM state
        let paragraphKeyPressLog = [];
        let liveAccuracyLog = [];

        // Stats
        let history = { wpm: [], accuracy: [], labels: [], overallWpmHistory: [], cumulativeWords: [], chapterIndices: [], paragraphWordCounts: [], cumulativeWordsInChapter: [], rawTimes: [], rawCorrectChars: [], rawTypedChars: [] };
        let historyChart;
        let isShowingAllHistory = false;
		let overallStats = {
            totalCorrectChars: 0,
            totalTypedChars: 0,
            totalTime: 0,
            cumulativeWordCount: 0,
        };

		const THEMES = {
            'default': 'Default',
            'espresso': 'Espresso',
            'matrix': 'Matrix', 
            'dracula': 'Dracula',
			'monkeytype': 'Monkeytype',
			'pinkpower': 'Pink Power',
			'gruvboxdark': 'Gruvbox Dark',
			'ryujin': 'Ryujin',
			'creamandberries': 'Cream & Berries',
			'terminal': 'Terminal',
			'nonconformist': 'Non-conformist',
			'olivegarden': 'Olive Garden',
			'boravia': 'Boravia',
			'plumpudding': 'Plum Pudding'
        };
	
	
		function checkAndScrollCursorIntoView() {
			if (!currentCursorSpan) return;

			const container = currentContentEl;
			const containerRect = container.getBoundingClientRect();
			const cursorRect = currentCursorSpan.getBoundingClientRect();
			const containerMidpoint = containerRect.top + (containerRect.height / 2);

			if (cursorRect.top > containerMidpoint) {
				const scrollOffset = cursorRect.top - containerMidpoint;
				container.scrollTo({
					top: container.scrollTop + scrollOffset,
					behavior: 'smooth'
				});
			}
		}	

		function getThemeColorWithOpacity(variableName, opacity) {
			const color = getComputedStyle(document.body).getPropertyValue(variableName).trim();
			const tempEl = document.createElement('div');
			tempEl.style.color = color;
			document.body.appendChild(tempEl);
			const rgbColor = getComputedStyle(tempEl).color;
			document.body.removeChild(tempEl);
			// Extract the r, g, b values from the "rgb(r, g, b)" string
			const [r, g, b] = rgbColor.match(/\d+/g);
			return `rgba(${r}, ${g}, ${b}, ${opacity})`;
		}
		
		function triggerFullscreenConfetti() {
			const duration = 3 * 1000; // 3 seconds for a nice burst
			const animationEnd = Date.now() + duration;
			const defaults = { startVelocity: 30, spread: 360, ticks: 60, zIndex: 100 };

			function randomInRange(min, max) {
				return Math.random() * (max - min) + min;
			}

			const interval = setInterval(function() {
				const timeLeft = animationEnd - Date.now();

				if (timeLeft <= 0) {
					return clearInterval(interval);
				}

				const particleCount = 50 * (timeLeft / duration);
				confetti({ ...defaults, particleCount, origin: { x: randomInRange(0.1, 0.3), y: Math.random() - 0.2 } });
				confetti({ ...defaults, particleCount, origin: { x: randomInRange(0.7, 0.9), y: Math.random() - 0.2 } });
			}, 250);
		}

        const getSettingsKey = () => `typingSettings_${currentUsername}`;

		const saveSettings = (settings) => {
            if (!currentUsername) return;
            localStorage.setItem(getSettingsKey(), JSON.stringify(settings));
        };

        const loadSettings = () => {
            const saved = localStorage.getItem(getSettingsKey());
            const defaults = { 
                fontFamily: 'roboto-mono', 
                fontSize: 'md',
                theme: 'default',
                inversion: false,
				dailyGoalInMinutes: 30
            };
            if (saved) {
                return { ...defaults, ...JSON.parse(saved) };
            }
            return defaults;
        };

		const applySettings = () => {
			const settings = loadSettings();
			const body = document.body;

			// 1. Apply Font & Size
			const fontClass = `font-${settings.fontFamily}`;
			const sizeClass = `font-size-${settings.fontSize}`;
			bookContentEl.className.split(' ').forEach(c => {
				if (c.startsWith('font-')) bookContentEl.classList.remove(c);
			});
			bookContentEl.classList.add(fontClass, sizeClass);

			// 2. Apply Theme
			body.dataset.theme = settings.theme;
			body.dataset.themeInversion = settings.inversion;

			// 3. Apply Cursor Style (derived from theme)
			const themeStyles = window.getComputedStyle(body);
			const cursorStyle = themeStyles.getPropertyValue('--theme-cursor-style').trim() || 'underline';
			body.dataset.cursorStyle = cursorStyle;
			
			// 4. Redraw the chart with new colors if it exists
			if (historyChart) {
				updateChart();
			}
			const fullReportViewEl = document.getElementById('full-report-view');
			if (fullReportViewEl && !fullReportViewEl.classList.contains('hidden')) {
				displayFullReport();
			}
		};
		
		const populateSettingsModal = () => {
			const currentSettings = loadSettings();
			const themeSelector = document.getElementById('theme-selector');
			const inversionSelector = document.getElementById('inversion-selector');
			const dailyGoalInput = document.getElementById('daily-goal-input');
			const fontFamilySelector = document.getElementById('font-family-selector');
			const fontSizeSelector = document.getElementById('font-size-selector');

			// --- Font Family Buttons ---
			fontFamilySelector.innerHTML = '';
			for (const key in FONT_OPTIONS) {
				const btn = document.createElement('button');
				btn.textContent = FONT_OPTIONS[key];
				btn.dataset.font = key;
				btn.className = `flex items-center justify-center p-3 rounded-md text-white transition-colors choice-btn ${currentSettings.fontFamily === key ? 'ui-action-button-primary choice-btn-active' : 'ui-action-button-secondary'}`;
				
				btn.addEventListener('click', () => {
					saveSettings({ ...loadSettings(), fontFamily: key });
					applySettings();
					populateSettingsModal();
				});

				fontFamilySelector.appendChild(btn);
			}

			// --- Font Size Buttons ---
			fontSizeSelector.innerHTML = '';
			for (const key in FONT_SIZES) {
				const btn = document.createElement('button');
				btn.textContent = FONT_SIZES[key];
				btn.dataset.size = key;
				btn.className = `flex items-center justify-center p-3 rounded-md text-white transition-colors choice-btn ${currentSettings.fontSize === key ? 'ui-action-button-primary choice-btn-active' : 'ui-action-button-secondary'}`;
				btn.addEventListener('click', () => {
					saveSettings({ ...loadSettings(), fontSize: key });
					applySettings();
					populateSettingsModal();
				});
				fontSizeSelector.appendChild(btn);
			}

			// Populate Theme Dropdown
			themeSelector.innerHTML = '';
			for (const key in THEMES) {
				const option = document.createElement('option');
                option.value = key;
                option.textContent = THEMES[key];
                if (currentSettings.theme === key) {
                    option.selected = true;
                }
                themeSelector.appendChild(option);
			}
			themeSelector.onchange = null; 
			themeSelector.onchange = (e) => {
				saveSettings({ ...loadSettings(), theme: e.target.value });
                applySettings();
                populateSettingsModal();
			};

			// Populate Inversion Buttons
			inversionSelector.innerHTML = '';
			const inversionOptions = { false: "Dark → Bright", true: "Bright → Dark"};
			for (const key in inversionOptions) {
				const btn = document.createElement('button');
				btn.textContent = inversionOptions[key];
				btn.dataset.inversion = key;
				const isActive = String(currentSettings.inversion) === key;
				btn.className = `flex items-center justify-center p-3 rounded-md text-white transition-colors choice-btn ${isActive ? 'ui-action-button-primary choice-btn-active' : 'ui-action-button-secondary'}`;
				btn.addEventListener('click', () => {
					saveSettings({ ...loadSettings(), inversion: key === 'true' });
					applySettings();
					populateSettingsModal();
				});
				inversionSelector.appendChild(btn);
			}
			if (dailyGoalInput) {
				dailyGoalInput.value = currentSettings.dailyGoalInMinutes;

				// 2. Add a listener to save the value when it's changed by the user
				dailyGoalInput.addEventListener('input', () => {
					let goal = parseInt(dailyGoalInput.value);
					if (goal < 1) goal = 1;
					if (goal > 300) goal = 300;
					
					// 4. Save the new setting
					saveSettings({ ...loadSettings(), dailyGoalInMinutes: goal });
					
					// 5. Instantly update the progress bar on the main screen
					updateDailyGoalDisplay(); 
				});
			}
        };
		
        const getAnalysisKey = () => `typingAnalysis_${currentUsername}`;

        const loadAnalysis = () => {
            const saved = localStorage.getItem(getAnalysisKey());
            // The structure for storing all performance data
            const defaultStructure = { bigrams: {}, trigrams: {}, entryDelays: {} };
            if (saved) {
                return { ...defaultStructure, ...JSON.parse(saved) };
            }
            return defaultStructure;
        };

        const saveAnalysis = (data) => {
            if (!currentUsername) return;
            localStorage.setItem(getAnalysisKey(), JSON.stringify(data));
        };

        // Analyzes the paragraph's performance and saves it to the user's profile
		const analyzeAndSaveParagraphStats = () => {
			const analysis = loadAnalysis();
			const paragraphData = currentParagraphAnalysis;
			const currentWordCount = overallStats.cumulativeWordCount;

			if (!analysis.bigrams) analysis.bigrams = {};
			if (!analysis.trigrams) analysis.trigrams = {};
			if (!analysis.metadata) analysis.metadata = {};

			// Save bigram data (as before)
			if (paragraphData.bigrams) {
				for (const bigram in paragraphData.bigrams) {
					if (MASTER_BIGRAMS_200.includes(bigram)) {
						if (!analysis.bigrams[bigram] || !Array.isArray(analysis.bigrams[bigram].events)) {
							analysis.bigrams[bigram] = { events: [] };
						}
						paragraphData.bigrams[bigram].delays.forEach(delay => {
							analysis.bigrams[bigram].events.push({ type: 'delay', value: delay, wordCount: currentWordCount });
						});
						for (let i = 0; i < paragraphData.bigrams[bigram].errors; i++) {
							analysis.bigrams[bigram].events.push({ type: 'error', wordCount: currentWordCount });
						}
					}
				}
			}
			
			// --- ADDED: Save trigram data ---
			if (paragraphData.trigrams) {	
				for (const trigram in paragraphData.trigrams) {
					if (MASTER_TRIGRAMS_200.includes(trigram)) {
						if (!analysis.trigrams[trigram] || !Array.isArray(analysis.trigrams[trigram].events)) {
							analysis.trigrams[trigram] = { events: [] };
						}
						paragraphData.trigrams[trigram].delays.forEach(delay => {
							analysis.trigrams[trigram].events.push({ type: 'delay', value: delay, wordCount: currentWordCount });
						});
						for (let i = 0; i < paragraphData.trigrams[trigram].errors; i++) {
							analysis.trigrams[trigram].events.push({ type: 'error', wordCount: currentWordCount });
						}
					}
				}
			}

			// Garbage Collection (now includes trigrams)
			const cutoffWordCount = Math.max(0, currentWordCount - 200);
			for (const bigram in analysis.bigrams) {
				analysis.bigrams[bigram].events = analysis.bigrams[bigram].events.filter(e => e.wordCount > cutoffWordCount);
				if (analysis.bigrams[bigram].events.length === 0) delete analysis.bigrams[bigram];
			}
			for (const trigram in analysis.trigrams) {
				analysis.trigrams[trigram].events = analysis.trigrams[trigram].events.filter(e => e.wordCount > cutoffWordCount);
				if (analysis.trigrams[trigram].events.length === 0) delete analysis.trigrams[trigram];
			}
			
			analysis.metadata = { totalWordsTyped: currentWordCount };
			saveAnalysis(analysis);
		};

		const displayAnalysis = () => {
			const analysis = loadAnalysis();
			
			const totalWordsTyped = analysis.metadata?.totalWordsTyped || 0;
			if (totalWordsTyped < 200) {
				weakBigramsList.innerHTML = `<p class="ui-bright-text text-sm">Type at least 200 words in your books to generate an analysis.</p>`;
				weakTrigramsList.innerHTML = `<p class="ui-bright-text text-sm">Keep practicing!</p>`;
				drillWeaknessesBtn.disabled = true;
				drillWeaknessesBtn.classList.add('opacity-50', 'cursor-not-allowed');
				return;
			}
			drillWeaknessesBtn.disabled = false;
			drillWeaknessesBtn.classList.remove('opacity-50', 'cursor-not-allowed');

			const getWeakestNgrams = (ngrams) => {
				return Object.entries(ngrams)
					.map(([ngram, data]) => {
						const recentDelays = data.events.filter(e => e.type === 'delay').map(e => e.value);
						const recentErrors = data.events.filter(e => e.type === 'error').length;
						const totalOccurrences = recentDelays.length + recentErrors;
						if (totalOccurrences === 0) return null;

						const avgCorrectDelay = recentDelays.length > 0 
							? recentDelays.reduce((a, b) => a + b, 0) / recentDelays.length 
							: 300;

						const errorPenalty = recentErrors * (avgCorrectDelay * 2);
						const totalTimeCost = recentDelays.reduce((a, b) => a + b, 0) + errorPenalty;
						
						// Calculate both the raw delay and the normalized score
						const rawAverageDelay = totalTimeCost / totalOccurrences;
						const normalizedScore = rawAverageDelay / (ngram.length > 1 ? ngram.length - 1 : 1);

						return { ngram, rawAverageDelay, normalizedScore, errors: recentErrors };
					})
					.filter(item => item !== null)
					.sort((a, b) => b.normalizedScore - a.normalizedScore) // Sort by the NORMALIZED score
					.slice(0, 5);
			};

			const weakBigrams = getWeakestNgrams(analysis.bigrams);
			const weakTrigrams = getWeakestNgrams(analysis.trigrams);

			const renderList = (element, list) => {
				element.innerHTML = '';
				if (list.length > 0) {
					list.forEach(item => {
						const el = document.createElement('div');
						el.className = 'ui-panel-bg p-2 rounded-md flex justify-between items-center text-sm';
						el.innerHTML = `
							<span class="font-bold ui-bright-text">${item.ngram}</span>
							<span class="ui-secondary-text">${Math.round(item.rawAverageDelay)}ms, ${item.errors} err</span>
						`; // Display the RAW average delay
						element.appendChild(el);
					});
				} else {
					element.innerHTML = `<p class="ui-secondary-text text-sm">Not enough recent data. Keep typing!</p>`;
				}
			};

			renderList(weakBigramsList, weakBigrams);
			renderList(weakTrigramsList, weakTrigrams);
		};
		
		const getDailyProgressKey = () => `typingDailyProgress_${currentUsername}`;

		const loadDailyProgress = () => {
			const saved = localStorage.getItem(getDailyProgressKey());
			return saved ? JSON.parse(saved) : {};
		};

		const saveDailyProgress = (progress) => {
			console.log("Attempting to save DAILY progress...");
			localStorage.setItem(getDailyProgressKey(), JSON.stringify(progress));
		};

        // --- PROFILE MANAGEMENT ---
		
        const PROFILES_KEY = 'typingAppProfiles';
        const LAST_USER_KEY = 'typingAppLastUser';

        const getProfiles = () => JSON.parse(localStorage.getItem(PROFILES_KEY)) || [];
        const saveProfiles = (profiles) => localStorage.setItem(PROFILES_KEY, JSON.stringify(profiles));

        const setupUser = () => {
            const profiles = getProfiles();
            const lastUser = localStorage.getItem(LAST_USER_KEY);

            if (lastUser && profiles.includes(lastUser)) {
                loadProfile(lastUser);
            } else if (profiles.length > 0) {
                profileSwitcherModal.classList.remove('hidden');
                showProfileSwitcher();
            } else {
                profileModal.classList.remove('hidden');
            }
        };

		const loadProfile = async (username) => {
			currentUsername = username;
			localStorage.setItem(LAST_USER_KEY, username);
			usernameDisplay.textContent = currentUsername;
			welcomeMessage.classList.remove('hidden');
			profileModal.classList.add('hidden');
			profileSwitcherModal.classList.add('hidden');
			
			// Run the migration script. It will only do work if needed.
			await runMigrationIfNeeded();
			
			applySettings(); 
			await renderLibrary();
		};

        const saveNewProfile = () => {
            const newUsername = usernameInput.value.trim();
            if (newUsername) {
                let profiles = getProfiles();
                if (profiles.includes(newUsername)) {
                    alert("A profile with this name already exists.");
                    return;
                }
                profiles.push(newUsername);
                saveProfiles(profiles);
                loadProfile(newUsername);
                usernameInput.value = '';
            }
        };
        
        const deleteProfile = (usernameToDelete) => {
            if (!confirm(`Are you sure you want to delete the profile "${usernameToDelete}"? All associated books and progress will be permanently lost.`)) return;

            Object.keys(localStorage)
				.filter(key => 
					key.startsWith(`typingProgress_${usernameToDelete}_`) || 
					key.startsWith(`typingLibrary_${usernameToDelete}`) ||
					key.startsWith(`typingAnalysis_${usernameToDelete}`) ||
					key.startsWith(`typingSettings_${usernameToDelete}`) ||
					key.startsWith(`typingDailyProgress_${usernameToDelete}`)
				)
                .forEach(key => localStorage.removeItem(key));
            
            let profiles = getProfiles();
            const newProfiles = profiles.filter(p => p !== usernameToDelete);
            saveProfiles(newProfiles);

            if (currentUsername === usernameToDelete) {
                localStorage.removeItem(LAST_USER_KEY);
                location.reload();
            } else {
                showProfileSwitcher();
            }
        };

		const showProfileSwitcher = () => {
            const profiles = getProfiles();
            profileListContainer.innerHTML = '';
            if (profiles.length === 0) {
                profileListContainer.innerHTML = `<p class="text-gray-400 text-center">No profiles found. Please create one.</p>`;
            } else {
                profiles.forEach(username => {
                    const profileItem = document.createElement('div');
                    profileItem.className = 'flex justify-between items-center p-3 rounded-md ui-panel-bg';
                    profileItem.innerHTML = `
                        <span class="font-medium ui-bright-text">${username}</span>
                        <div class="space-x-2">
                            <button data-username="${username}" class="load-profile-btn font-bold py-1 px-3 rounded-md text-sm ui-action-button-primary">Load</button>
                            <button data-username="${username}" class="delete-profile-btn font-bold py-1 px-3 rounded-md text-sm ui-action-button-danger">Delete</button>
                        </div>
                    `;
                    profileListContainer.appendChild(profileItem);
                });
            }
            profileSwitcherModal.classList.remove('hidden');
        };
		
        const getProgressSaveKey = () => `typingProgress_${currentUsername}_${currentBookIdentifier}`;
        const getLibrarySaveKey = () => `typingLibrary_${currentUsername}`;

        const saveProgress = () => {
			console.log("Attempting to save MAIN progress...");
            if (!currentUsername || !currentBookIdentifier) return;
            const progress = {
                currentChapterIndex,
                currentParagraphIndexInChapter,
                overallStats,
                history,
                lastUpdated: Date.now()
            };
            localStorage.setItem(getProgressSaveKey(), JSON.stringify(progress));
        };

		const loadProgress = () => {
            const savedData = localStorage.getItem(getProgressSaveKey());
            if (savedData) {
                const progress = JSON.parse(savedData);
                currentChapterIndex = progress.currentChapterIndex;
                currentParagraphIndexInChapter = progress.currentParagraphIndexInChapter;
                overallStats = progress.overallStats;
                history = progress.history;
        
                if (!history.paragraphWordCounts) history.paragraphWordCounts = [];
                if (!history.cumulativeWordsInChapter) history.cumulativeWordsInChapter = [];
                if (!history.rawTimes) history.rawTimes = [];
                if (!history.rawCorrectChars) history.rawCorrectChars = [];
                if (!history.rawTypedChars) history.rawTypedChars = [];
                if (!history.timestamps) history.timestamps = [];
        
                return true;
            }

            // If no saved data is found, reset stats as normal
            history = { wpm: [], accuracy: [], labels: [], overallWpmHistory: [], cumulativeWords: [], chapterIndices: [], paragraphWordCounts: [], cumulativeWordsInChapter: [], rawTimes: [], rawCorrectChars: [], rawTypedChars: [], timestamps: [] };
            overallStats = { totalCorrectChars: 0, totalTypedChars: 0, totalTime: 0, cumulativeWordCount: 0 };
            return false;
        };

        // --- LIBRARY MANAGEMENT ---
        const getLibrary = () => JSON.parse(localStorage.getItem(getLibrarySaveKey())) || [];
        const saveLibrary = (library) => localStorage.setItem(getLibrarySaveKey(), JSON.stringify(library));

		async function initDB() {
			const db = await idb.openDB(DB_NAME, DB_VERSION, {
				upgrade(db) {
					if (!db.objectStoreNames.contains(STORE_NAME)) {
						db.createObjectStore(STORE_NAME, { keyPath: 'id' });
					}
				},
			});
			return db;
		}

		async function saveBookData(bookData) {
			const db = await initDB();
			await db.put(STORE_NAME, bookData);
		}
		
		async function getBookData(bookId) {
			const db = await initDB();
			return await db.get(STORE_NAME, bookId);
		}
		
		async function runMigrationIfNeeded() {
			const library = getLibrary();

			if (!library || library.length === 0 || !library[0].chapterMarkers) {
				return; // No migration needed.
			}

			console.log("Old library format detected. Starting one-time migration to IndexedDB...");

			try {
				const newLibraryMetadata = [];
				for (const oldBook of library) {
					// 2. Prepare the large data object for IndexedDB
					const bookFileForDB = {
						id: oldBook.identifier,
						cover: oldBook.cover,
						chapterMarkers: oldBook.chapterMarkers
					};
					// 3. Move the large data
					await saveBookData(bookFileForDB);

					// 4. Create the small metadata object for the new library
					const bookMetadataForLocal = {
						bookName: oldBook.bookName,
						author: oldBook.author,
						identifier: oldBook.identifier,
						userChapterChoices: oldBook.userChapterChoices
					};
					newLibraryMetadata.push(bookMetadataForLocal);
				}

				saveLibrary(newLibraryMetadata);
				
				console.log("Library migration complete!");

			} catch (error) {
				console.error("Migration failed:", error);
				alert("There was an error upgrading your library. Some books may not work correctly. Please consider re-adding them.");
			}
		}

		const renderLibrary = async () => {
			const library = getLibrary();
			libraryList.innerHTML = '';

			if (library.length === 0) {
				libraryList.className = 'text-center col-span-full';
				libraryList.innerHTML = `<p class="text-gray-400">Your library is empty. Add a book to get started!</p>`;
			} else {
				libraryList.className = 'grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-6';
				
				for (const [index, book] of library.entries()) {
					let coverSrc = null;
					const bookDataFromDB = await getBookData(book.identifier);
					
					if (bookDataFromDB && bookDataFromDB.cover) {
						coverSrc = bookDataFromDB.cover;
					} else if (book.cover) {
						coverSrc = book.cover;
					}

					const bookElement = document.createElement('div');
					bookElement.className = 'library-book-card rounded-lg flex flex-col text-center shadow-lg overflow-hidden';
					
					bookElement.innerHTML = `
						<img src="${coverSrc || 'https://via.placeholder.com/300x450.png?text=No+Cover'}" alt="Cover for ${book.bookName}" class="w-full h-auto">
						<div class="p-4 flex flex-col flex-grow w-full">
							<h3 class="font-bold text-md leading-tight mb-1 truncate" title="${book.bookName}">${book.bookName}</h3>
							<p class="text-sm mb-4 truncate" title="${book.author}">${book.author}</p>
							<div class="mt-auto space-y-2 w-full">
								<button class="start-typing-btn w-full font-bold py-2 px-3 rounded-md text-sm ui-action-button-primary">Type</button>
								<button class="delete-book-btn w-full font-bold py-2 px-3 rounded-md text-sm ui-action-button-danger">Delete</button>
							</div>
						</div>
					`;

					// Add event listeners directly to the new buttons
					bookElement.querySelector('.start-typing-btn').addEventListener('click', () => startTypingBook(book));
					bookElement.querySelector('.delete-book-btn').addEventListener('click', () => deleteBook(index));

					libraryList.appendChild(bookElement);
				};
			}
		};
		
        const deleteBook = (index) => {
             let library = getLibrary();
             const bookToDelete = library[index];
            if (!confirm(`Are you sure you want to delete "${bookToDelete.bookName}" from your library?`)) return;
            localStorage.removeItem(`typingProgress_${currentUsername}_${bookToDelete.identifier}`);
            library.splice(index, 1);
            saveLibrary(library);
            renderLibrary();
        };

		function formatSeconds(totalSeconds) {
				if (isNaN(totalSeconds) || totalSeconds === 0) return '0m';
				const hours = Math.floor(totalSeconds / 3600);
				const minutes = Math.floor((totalSeconds % 3600) / 60);

				let result = '';
				if (hours > 0) {
					result += `${hours}h `;
				}
				result += `${minutes}m`;
				return result.trim();
			}

			function calculateAndDisplayLifetimeStats() {
				let timeAll = 0, wordsAll = 0, time30d = 0, words30d = 0;
				const thirtyDaysAgo = Date.now() - 30 * 24 * 60 * 60 * 1000;

				// 1. Calculate Time Practiced from daily progress logs
				const dailyProgress = loadDailyProgress();
				for (const dateStr in dailyProgress) {
					const practiceDate = new Date(dateStr + "T00:00:00");
					const seconds = dailyProgress[dateStr];
					timeAll += seconds;
					if (practiceDate.getTime() >= thirtyDaysAgo) {
						time30d += seconds;
					}
				}

				// 2. Calculate Words Typed from all books in the library
				const library = getLibrary();
				library.forEach(book => {
					const progress = JSON.parse(localStorage.getItem(`typingProgress_${currentUsername}_${book.identifier}`));
					if (progress && progress.history && progress.history.paragraphWordCounts) {
						progress.history.paragraphWordCounts.forEach((wordCount, i) => {
							wordsAll += wordCount;
							const timestamp = progress.history.timestamps ? progress.history.timestamps[i] : null;
							if (timestamp && timestamp >= thirtyDaysAgo) {
								words30d += wordCount;
							}
						});
					}
				});

				// 3. Update the DOM in the report view
				document.getElementById('report-stats-time-all').textContent = formatSeconds(timeAll);
				document.getElementById('report-stats-words-all').textContent = wordsAll.toLocaleString('en-US');
				document.getElementById('report-stats-time-30d').textContent = formatSeconds(time30d);
				document.getElementById('report-stats-words-30d').textContent = words30d.toLocaleString('en-US');
			}

        // --- UI NAVIGATION ---

        const showFileLoaderView = () => {
            libraryView.classList.add('hidden');
            fileLoaderSection.classList.remove('hidden');
            typingAppSection.classList.add('hidden');
            typingAppSection.classList.remove('flex');
			mainFooter.classList.add('hidden');
        };
        
		const showLibraryView = () => {
			libraryView.classList.remove('hidden');
			fileLoaderSection.classList.add('hidden');
			typingAppSection.classList.add('hidden');
			typingAppSection.classList.remove('flex');
			reportsView.classList.add('hidden');
			reportsView.classList.remove('flex');
			mainNavBar.classList.add('hidden');
			mainNavBar.classList.remove('flex');
			legacyHeader.classList.remove('hidden');
			welcomeMessage.classList.remove('hidden');
			mainFooter.classList.remove('hidden');
		};

		const showTypingView = (book) => {
			libraryView.classList.add('hidden');
			fileLoaderSection.classList.add('hidden');
			typingAppSection.classList.remove('hidden');
			typingAppSection.classList.add('flex');
			reportsView.classList.add('hidden');
			reportsView.classList.remove('flex');
			mainNavBar.classList.remove('hidden');
			mainNavBar.classList.add('flex');
			legacyHeader.classList.add('hidden');
			welcomeMessage.classList.add('hidden');
			mainFooter.classList.add('hidden');
			navBookTitleBtn.style.visibility = 'visible';

			// Populate nav bar
			navUsername.textContent = `Hi ${currentUsername}!`;
			navBookTitle.textContent = formatNavTitle(book.bookName);

			// Set active button
			[navTypingBtn, navReportsBtn, navLibraryBtn].forEach(btn => btn.classList.remove('nav-btn-active'));
			navTypingBtn.classList.add('nav-btn-active');
		};

		const showReportsView = (book) => {
			libraryView.classList.add('hidden');
			fileLoaderSection.classList.add('hidden');
			typingAppSection.classList.add('hidden');
			typingAppSection.classList.remove('flex');
			reportsView.classList.remove('hidden');
			reportsView.classList.add('flex');
			mainNavBar.classList.remove('hidden');
			mainNavBar.classList.add('flex');
			legacyHeader.classList.add('hidden');
			welcomeMessage.classList.add('hidden');
			mainFooter.classList.add('hidden');
			navBookTitleBtn.style.visibility = 'hidden';

			// Populate nav bar
			navUsername.textContent = `Hi ${currentUsername}!`;
			navBookTitle.textContent = formatNavTitle(book.bookName);

			// Set active button
			[navTypingBtn, navReportsBtn, navLibraryBtn].forEach(btn => btn.classList.remove('nav-btn-active'));
			navReportsBtn.classList.add('nav-btn-active');
		};
		
		function stopDailyProgressTimer() {
			if (dailyProgressTimer) {
				clearInterval(dailyProgressTimer); // Stop the interval
				dailyProgressTimer = null;

				// Calculate how much time passed in the paragraph we just stopped
				const paragraphElapsedTime = (Date.now() - paragraphStartTime) / 1000;

				// Add that time to our main in-memory counter
				const today = new Date().toISOString().split('T')[0];
				const progress = loadDailyProgress();
				const timeBeforeUpdate = progress[today] || 0;

				secondsPracticedToday += paragraphElapsedTime;
				const newTime = secondsPracticedToday;

				// Check if the goal was just crossed
				const dailyGoalSeconds = (loadSettings().dailyGoalInMinutes || 30) * 60;
				if (timeBeforeUpdate < dailyGoalSeconds && newTime >= dailyGoalSeconds) {
					console.log("Daily goal reached!");
					triggerFullscreenConfetti();
				}
				
				// Now save the new, accurate total to localStorage
				progress[today] = newTime;
				saveDailyProgress(progress);
			}
		}
		function updateLiveTimer() {
			// Calculate how long this paragraph has been active
			const paragraphElapsedTime = (Date.now() - paragraphStartTime) / 1000;
			
			// Get the total time from before this paragraph started
			const baseTime = secondsPracticedToday;

			// Update the display with the combined time
			updateDailyGoalDisplay(baseTime + paragraphElapsedTime);
		}
		
		function isParagraphLegitimate(index) {
			const p = currentChapterParagraphs[index];
			// Rule: Paragraph must exist and have text.
			if (!p || !p.text) return false;
			// Rule: Text must be longer than 10 characters.
			if (p.text.length <= 10) return false;
			
			// Rule: Text must contain at least one letter or number from ANY language.
			if (!/[\p{L}\p{N}]/u.test(p.text)) return false;
			
			// If all rules pass, it's a legitimate paragraph.
			return true;
		}
		
		function processHistoricalData() {
			const report = {
				stats: {
					currentStreak: 0,
					longestStreak: 0,
					avgWpmLast30d: 0,
					avgAccLast30d: 0,
				},
				heatmapData: {},
				wpmTrendData: {
					labels: Array.from({ length: 52 }, (_, i) => `Week ${i + 1}`),
					wpm: Array(52).fill(null)
				}
			};

			const dailyProgress = loadDailyProgress();

			for (const dateStr in dailyProgress) {
				report.heatmapData[dateStr] = dailyProgress[dateStr];
			}

			// Streak logic now only calculates streaks and no longer affects the heatmap.
			const validStreakDates = Object.keys(dailyProgress).filter(date => dailyProgress[date] >= 300);
			const sortedDates = validStreakDates.sort();
			
			if (sortedDates.length > 0) {
				let currentStreak = 0;
				let longestStreak = 0;
				let lastDate = new Date(sortedDates[sortedDates.length - 1] + "T00:00:00");
				
				const today = new Date();
				today.setHours(0,0,0,0);
				const yesterday = new Date();
				yesterday.setDate(today.getDate() - 1);

				// Check if the most recent practice day is today or yesterday to anchor the streak
				if (lastDate.getTime() !== today.getTime() && lastDate.getTime() !== yesterday.getTime()) {
					 currentStreak = 0;
				} else {
					// Start streak calculation from the last valid day
					for (let i = sortedDates.length - 1; i >= 0; i--) {
						const currentDate = new Date(sortedDates[i] + "T00:00:00");
						const diffDays = (lastDate - currentDate) / (1000 * 60 * 60 * 24);

						if (diffDays <= 1) {
							currentStreak++;
						} else {
							break; // Streak is broken
						}
						if (currentStreak > longestStreak) {
							longestStreak = currentStreak;
						}
						lastDate = currentDate;
					}
				}
				
				// Calculate the longest streak overall by re-iterating
				longestStreak = 0;
				if(sortedDates.length > 0) {
					let tempStreak = 1;
					longestStreak = 1;
					let tempLastDate = new Date(sortedDates[0] + "T00:00:00");
					for(let i=1; i < sortedDates.length; i++) {
						const currentDate = new Date(sortedDates[i] + "T00:00:00");
						const diffDays = (currentDate - tempLastDate) / (1000 * 60 * 60 * 24);
						if(diffDays === 1) {
							tempStreak++;
						} else {
							tempStreak = 1;
						}
						if(tempStreak > longestStreak) {
							longestStreak = tempStreak;
						}
						tempLastDate = currentDate;
					}
				}

				report.stats.currentStreak = currentStreak;
				report.stats.longestStreak = longestStreak;
			}

			const allHistory = [];
			const library = getLibrary();
			library.forEach(book => {
				const progress = JSON.parse(localStorage.getItem(`typingProgress_${currentUsername}_${book.identifier}`));
				if (progress && progress.history && progress.history.wpm) {
					progress.history.wpm.forEach((wpm, i) => {
						if (wpm === null) return;
						const paragraphTimestamp = (progress.history.timestamps && progress.history.timestamps[i])
							? progress.history.timestamps[i]
							: progress.history.lastUpdated - (progress.history.rawTimes.slice(i + 1).reduce((a, b) => a + b, 0) * 1000);

						allHistory.push({
							timestamp: paragraphTimestamp,
							wpm: wpm,
							acc: progress.history.accuracy[i],
							time: progress.history.rawTimes[i],
							chars: progress.history.rawTypedChars[i]
						});
					});
				}
			});

			if (allHistory.length > 0) {
				const thirtyDaysAgo = Date.now() - 30 * 24 * 60 * 60 * 1000;
				const recentHistory = allHistory.filter(p => p.timestamp > thirtyDaysAgo);
				if(recentHistory.length > 0) {
					report.stats.avgWpmLast30d = recentHistory.reduce((sum, p) => sum + p.wpm, 0) / recentHistory.length;
					report.stats.avgAccLast30d = recentHistory.reduce((sum, p) => sum + p.acc, 0) / recentHistory.length;
				}

				allHistory.sort((a, b) => a.timestamp - b.timestamp);
				const firstPracticeDate = new Date(allHistory[0].timestamp);
				firstPracticeDate.setHours(0, 0, 0, 0);

				const dayOfWeek = firstPracticeDate.getDay();
				const diff = firstPracticeDate.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1); 
				const startOfWeek1 = new Date(firstPracticeDate.setDate(diff));

				const weeklyData = {};
				allHistory.forEach(p => {
					const practiceDate = new Date(p.timestamp);
					const timeDifference = practiceDate - startOfWeek1;
					const weekIndex = Math.floor(timeDifference / (1000 * 60 * 60 * 24 * 7));

					if (weekIndex >= 0 && weekIndex < 52) {
						if (!weeklyData[weekIndex]) {
							weeklyData[weekIndex] = [];
						}
						weeklyData[weekIndex].push({ time: p.time, chars: p.chars });
					}
				});

				for (const weekIndex in weeklyData) {
					const weekData = weeklyData[weekIndex];
					const totalChars = weekData.reduce((sum, entry) => sum + entry.chars, 0);
					const totalTime = weekData.reduce((sum, entry) => sum + entry.time, 0);

					if (totalTime > 0) {
						const aggregateWpm = (totalChars / CHARS_PER_WORD) / (totalTime / 60);
						report.wpmTrendData.wpm[weekIndex] = aggregateWpm;
					}
				}
			}
			
			return report;
		}
		
		const showDrillView = () => {
			libraryView.classList.add('hidden');
			fileLoaderSection.classList.add('hidden');
			typingAppSection.classList.add('hidden');
			typingAppSection.classList.remove('flex');
			analysisModal.classList.add('hidden');
			
			reportsView.classList.add('hidden');
			reportsView.classList.remove('flex');

			drillModeSection.classList.remove('hidden');
			drillModeSection.classList.add('flex');

			appTitleHeader.classList.add('hidden');
			bookTitleHeader.classList.remove('hidden');
			navBookTitleBtn.style.visibility = 'hidden';
		};
		const startDrill = () => {
			isDrillActive = true;
			currentParagraphIndexInChapter = -1;
			currentContentEl = drillContentEl;

			const analysis = loadAnalysis();
			
			const totalWordsTyped = analysis.metadata?.totalWordsTyped || 0;
			if (totalWordsTyped < 200) {
				alert("You need to type at least 200 words before you can use the drill feature.");
				analysisModal.classList.add('hidden');
				return;
			}

			const getWeakest = (ngrams) => {
				return Object.entries(ngrams)
					.map(([ngram, data]) => {
						const recentDelays = data.events.filter(e => e.type === 'delay').map(e => e.value);
						const recentErrors = data.events.filter(e => e.type === 'error').length;
						const totalOccurrences = recentDelays.length + recentErrors;
						if (totalOccurrences === 0) return null;
						const avgCorrectDelay = recentDelays.length > 0 ? recentDelays.reduce((a, b) => a + b, 0) / recentDelays.length : 300;
						const errorPenalty = recentErrors * (avgCorrectDelay * 2);
						const totalTimeCost = recentDelays.reduce((a, b) => a + b, 0) + errorPenalty;
						const score = totalTimeCost / totalOccurrences;
						return { ngram, weaknessScore: score };
					})
					.filter(item => item !== null)
					.sort((a, b) => b.weaknessScore - a.weaknessScore)
					.slice(0, 10);
			};

			const weakBigrams = getWeakest(analysis.bigrams);
			const weakTrigrams = getWeakest(analysis.trigrams);

			const tier1Weaknesses = [...weakBigrams.slice(0, 5), ...weakTrigrams.slice(0, 5)].sort((a, b) => b.weaknessScore - a.weaknessScore);
			const tier2Weaknesses = [...weakBigrams.slice(5, 10), ...weakTrigrams.slice(5, 10)];

			if (tier1Weaknesses.length === 0) {
				alert("Not enough analysis data from the last 200 words. Please type a few more paragraphs.");
				isDrillActive = false;
				analysisModal.classList.add('hidden');
				return;
			}

			const DRILL_SIZE = 50;
			let practiceSet = [];
			const usedWords = new Set();
			const totalTier1Score = tier1Weaknesses.reduce((sum, item) => sum + item.weaknessScore, 0);

			if (totalTier1Score > 0) {
				tier1Weaknesses.forEach(weakness => {
					const wordCountForThisNgram = Math.round((weakness.weaknessScore / totalTier1Score) * DRILL_SIZE);
					if (wordCountForThisNgram < 1) return;
					const matchingWords = MASTER_WORDS_2K.filter(word => word.includes(weakness.ngram) && !usedWords.has(word));
					matchingWords.sort(() => 0.5 - Math.random());
					const wordsToAdd = matchingWords.slice(0, wordCountForThisNgram);
					wordsToAdd.forEach(word => {
						practiceSet.push(word);
						usedWords.add(word);
					});
				});
			}

			if (practiceSet.length < DRILL_SIZE && tier2Weaknesses.length > 0) {
				const remainingNeeded = DRILL_SIZE - practiceSet.length;
				const tier2MatchingWords = MASTER_WORDS_2K.filter(word => tier2Weaknesses.some(w => word.includes(w.ngram)) && !usedWords.has(word));
				tier2MatchingWords.sort(() => 0.5 - Math.random());
				const wordsToAdd = tier2MatchingWords.slice(0, remainingNeeded);
				wordsToAdd.forEach(word => { 
					practiceSet.push(word);
					usedWords.add(word);
				});
			}

			if (practiceSet.length < DRILL_SIZE) {
				const remainingNeeded = DRILL_SIZE - practiceSet.length;
				const randomFillWords = MASTER_WORDS_2K.filter(word => !usedWords.has(word)).sort(() => 0.5 - Math.random());
				const wordsToAdd = randomFillWords.slice(0, remainingNeeded);
				wordsToAdd.forEach(word => { 
					practiceSet.push(word);
					usedWords.add(word);
				});
			}
			
			practiceSet.sort(() => 0.5 - Math.random());
			const drillSet = practiceSet.slice(0, DRILL_SIZE);
			
			drillTotalWords = drillSet.length;

			const drillParagraph = drillSet.join(' ');
			if (!drillParagraph) {
				alert("Could not generate a drill. Please type a few more paragraphs in a book to generate more analysis data.");
				return;
			}
			drillTargetLength = drillParagraph.length;
			currentChapterParagraphs = [{ text: drillParagraph, html: drillParagraph }];
			const totalWeaknesses = tier1Weaknesses.length + tier2Weaknesses.length;
			drillWordCount.textContent = `0 / ${drillTotalWords}`;

			showDrillView();
			renderDrill();
			activateNextParagraph(true);
		};
		
		const createFanfareText = (text) => {
			return text.split('').map(char => {
				if (char === ' ') { return ' '; } // Keep spaces as normal characters
				const delay = (Math.random() * -1.5).toFixed(2);
				return `<span class="fanfare-char" style="animation-delay: ${delay}s;">${char}</span>`;
			}).join('');
		};

		const finishDrill = () => {
			if (!isDrillActive) return;

			const totalTime = (paragraphKeyPressLog.length > 1) ? (paragraphKeyPressLog[paragraphKeyPressLog.length - 1].time - paragraphKeyPressLog[0].time) / 1000 : 0;
			const typedChars = currentUserInput.length;
			let correctChars = 0;
			const sourceText = currentChapterParagraphs[0].text;
			for (let i = 0; i < typedChars; i++) {
				if (currentUserInput[i] === sourceText[i]) correctChars++;
			}

			const finalWPM = (totalTime > 0) ? ((typedChars / CHARS_PER_WORD) / (totalTime / 60)) : 0;
			const finalAccuracy = (typedChars > 0) ? (correctChars / typedChars) * 100 : 0;

			drillWpmDisplay.textContent = finalWPM.toFixed(1);
			drillAccuracyDisplay.textContent = `${finalAccuracy.toFixed(0)}%`;
			
			drillWordCount.textContent = `${drillTotalWords} / ${drillTotalWords}`;
			triggerFullscreenConfetti();

			currentContentEl = bookContentEl;
			
			const fanfareText = createFanfareText("Drill Complete! Good job!");

			drillContentEl.innerHTML = `
				<div class="text-center p-8 rounded-lg">
					<h2 class="text-3xl font-bold mb-4 ui-subheading">${fanfareText}</h2>
					<div class="flex justify-center space-x-8 mt-4">
						<div>
							<p class="text-sm ui-stat-label">WPM</p>
							<div class="text-3xl font-bold ui-stat-value">${finalWPM.toFixed(1)}</div>
						</div>
						<div>
							<p class="text-sm ui-stat-label">Accuracy</p>
							<div class="text-3xl font-bold ui-stat-value">${finalAccuracy.toFixed(0)}%</div>
						</div>
			
					</div>
				</div>
			`;
		};
		
		function cleanupDrillState() {
			isDrillActive = false;
			currentContentEl = bookContentEl; // Reset the active typing area to the main one
			drillModeSection.classList.add('hidden');
			drillModeSection.classList.remove('flex');
			navBookTitleBtn.style.visibility = 'visible';
		}

		// --- Global variable for the trend chart ---
		let wpmTrendChart;

		// --- A. Main function to show and populate the report ---
		function displayFullReport() {
			const reportData = processHistoricalData();
			calculateAndDisplayLifetimeStats();

			// Populate the stats
			document.getElementById('stats-current-streak').textContent = `${reportData.stats.currentStreak} days`;
			document.getElementById('stats-longest-streak').textContent = `${reportData.stats.longestStreak} days`;
			document.getElementById('stats-avg-wpm').textContent = reportData.stats.avgWpmLast30d.toFixed(1);
			document.getElementById('stats-avg-acc').textContent = `${reportData.stats.avgAccLast30d.toFixed(1)}%`;

			// Render the default view (heatmap)
			renderHeatmap(reportData.heatmapData);
			// Prepare the WPM trend graph (it starts hidden)
			renderWpmTrendGraph(reportData.wpmTrendData);
		}

		// --- B. Function to render the heatmap ---

		function renderHeatmap(data) {
			const container = document.getElementById('heatmap-container');
			const monthsContainer = document.getElementById('heatmap-months-container');
			container.innerHTML = '';
			monthsContainer.innerHTML = '';

			const dates = Object.keys(data);

			// First, check if there is any activity data at all
			if (dates.length === 0) {
				container.innerHTML = '<p class="text-center ui-secondary-text col-span-full">No activity yet. Start typing to see your progress!</p>';
				return; // Exit the function if there's nothing to display
			}

			// If we have data, proceed to create the month labels
			dates.sort();
			const firstPracticeDate = new Date(dates[0] + "T00:00:00");
			const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
			let startMonth = firstPracticeDate.getMonth();
			
			for (let i = 0; i < 12; i++) {
				const monthLabel = document.createElement('span');
				monthLabel.textContent = monthNames[(startMonth + i) % 12];
				monthsContainer.appendChild(monthLabel);
			}

			const startDate = new Date(firstPracticeDate);
			const endDate = new Date(startDate);
			endDate.setDate(startDate.getDate() + 365); // Set the window to be 1 year from the start date

			container.style.display = 'grid';
			container.style.gridTemplateRows = 'repeat(7, 1fr)';
			container.style.gridAutoFlow = 'column';
			container.style.gap = '3px';

			// Add blank days at the beginning to align the first day of practice correctly on the grid
			for (let i = 0; i < startDate.getDay(); i++) {
				const blankSquare = document.createElement('div');
				blankSquare.style.width = '15px';
				blankSquare.style.height = '15px';
				container.appendChild(blankSquare);
			}

			// Loop from the first practice day for 365 days
			for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
				const daySquare = document.createElement('div');
				daySquare.style.width = '15px';
				daySquare.style.height = '15px';
				daySquare.style.borderRadius = '2px';

				const dateString = d.toISOString().split('T')[0];
				const secondsTyped = data[dateString] || 0;

				let color = getThemeColorWithOpacity('--theme-ui-bright', 0.05);
				if (secondsTyped > 0) {
					const minutesTyped = secondsTyped / 60;
					const goalMinutes = (loadSettings().dailyGoalInMinutes || 30);
					const percentageOfGoal = Math.min(1, minutesTyped / goalMinutes);
					if (percentageOfGoal < 0.25) color = getThemeColorWithOpacity('--theme-ui-bright', 0.2);
					else if (percentageOfGoal < 0.5) color = getThemeColorWithOpacity('--theme-ui-bright', 0.4);
					else if (percentageOfGoal < 1) color = getThemeColorWithOpacity('--theme-ui-bright', 0.7);
					else color = getThemeColorWithOpacity('--theme-ui-bright', 1.0);
				}

				daySquare.style.backgroundColor = color;
				daySquare.title = `${dateString}: ${Math.round(secondsTyped / 60)} minutes typed`;
				container.appendChild(daySquare);
			}
		}

	
		// --- C. Function to render the WPM trend graph ---

		function renderWpmTrendGraph(data) {
			const ctx = document.getElementById('wpm-trend-chart').getContext('2d');
			if (wpmTrendChart) {
				wpmTrendChart.destroy();
			}
			const themeStyles = getComputedStyle(document.body);
			const brightTextColor = themeStyles.getPropertyValue('--theme-ui-bright').trim(); 
			const wpmColor = themeStyles.getPropertyValue('--theme-ui-medium').trim();

			wpmTrendChart = new Chart(ctx, {
				type: 'bar',
				data: {
					labels: data.labels,
					datasets: [{
						label: 'Weekly Avg WPM',
						data: data.wpm,
						backgroundColor: wpmColor,
					}]
				},
				options: {
					aspectRatio: 4,
					plugins: {
						legend: { display: false }
					},
					scales: {
						y: { // Simplified Y axis for WPM
							beginAtZero: true,
							title: { display: true, text: 'WPM', color: brightTextColor },
							ticks: { color: brightTextColor },
							grid: { color: 'rgba(255, 255, 255, 0.1)' }
						},
						x: {
							ticks: { color: brightTextColor },
							grid: { display: false }
						}
					}
				}
			});
		}
		
		document.addEventListener('DOMContentLoaded', () => {
			const fullReportBtn = document.getElementById('full-report-btn');
			const historyChartContainer = document.getElementById('history-chart-container');
			const fullReportViewEl = document.getElementById('full-report-view');
			const heatmapContainer = document.getElementById('heatmap-container');
			const wpmTrendChartEl = document.getElementById('wpm-trend-chart');
			const historyTitle = document.querySelector('.ui-chart-container h3');

			// Main toggle for the report

			fullReportBtn.addEventListener('click', () => {
				const isReportHidden = fullReportViewEl.classList.contains('hidden');
				const chartToggleButton = document.getElementById('chart-toggle-btn');

				if (isReportHidden) {
					historyChartContainer.classList.add('hidden');
					fullReportViewEl.classList.remove('hidden');
					displayFullReport();
					fullReportBtn.textContent = 'Back to History';
					historyTitle.textContent = 'Typing Statistics';
					chartToggleButton.style.visibility = 'hidden';
				} else {
					fullReportViewEl.classList.add('hidden');
					historyChartContainer.classList.remove('hidden');
					fullReportBtn.textContent = 'Full Report';
					historyTitle.textContent = 'Performance History';
					chartToggleButton.style.visibility = 'visible';
				}
			});

		});
		
        // --- HELPER FUNCTION TO CONVERT BLOB URL TO BASE64 ---
        const blobUrlToBase64 = (url) => {
            return new Promise((resolve, reject) => {
                if (!url) {
                    resolve(null);
                    return;
                }
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                fetch(url)
                    .then(res => res.blob())
                    .then(blob => reader.readAsDataURL(blob))
                    .catch(reject);
            });
        };

        // --- FILE LOADING & CHAPTER PARSING ---
		const handleFile = async (file) => {
			if (file && file.name.endsWith('.epub')) {
				loadingStatus.textContent = 'Loading EPUB...';
				isBookLoading = true;
				try {
					const book = ePub(file);
					await book.ready;
					
					const metadata = book.packaging.metadata;
					let coverBase64 = null;

					try {
						const coverUrl = await book.coverUrl();
						if (coverUrl) { // Only proceed if a cover URL was actually found
							coverBase64 = await blobUrlToBase64(coverUrl);
						}
					} catch (coverError) {
						console.warn("Could not load cover for this EPUB, proceeding without it:", coverError);
					}

					const allSections = [];
					const MIN_TEXT_LENGTH = 200;

					const processTocItems = async (tocItems) => {
						for (const item of tocItems) {
							const cleanHref = item.href.split('#')[0];
							const doc = await book.load(cleanHref);
							const body = doc.body || doc.documentElement;
							const htmlContent = body.innerHTML;

							const tempDiv = document.createElement('div');
							tempDiv.innerHTML = htmlContent;
							const textContent = (tempDiv.textContent || "").trim();
							
							if (textContent.length > MIN_TEXT_LENGTH) {
								allSections.push({
									title: item.label.trim(),
									htmlContent: htmlContent
								});
							}

							if (item.subitems && item.subitems.length > 0) {
								await processTocItems(item.subitems);
							}
						}
					};

					await processTocItems(book.navigation.toc);
					
					prepareBookForSelection(metadata, coverBase64, allSections);
				} catch (error) {
					loadingStatus.textContent = `Error processing EPUB file: ${error.message}`;
					console.error(error);
				} finally {
					isBookLoading = false;
				}
			} else {
				alert('Please select or drop a valid .epub file.');
			}
		};
		
		const prepareBookForSelection = (metadata, cover, allSections) => {
            tempBookData.title = metadata.title;
            tempBookData.author = metadata.creator;
            tempBookData.cover = cover;
            tempBookData.identifier = `${metadata.title}-${metadata.creator}`.replace(/\s+/g, '-');
            tempBookData.chapterMarkers = allSections;

            chapterListContainer.innerHTML = '';
            tempBookData.chapterMarkers.forEach((marker, index) => {
                const item = document.createElement('div');
                item.className = 'flex justify-between items-center p-3 rounded-md mb-2 ui-panel-bg';
                item.innerHTML = `
                    <span class="truncate ui-bright-text">${marker.title}</span>
                    <div class="flex space-x-2" data-index="${index}">
                        <button class="choice-btn font-bold py-1 px-3 rounded-md text-sm ui-action-button-primary choice-btn-active" data-choice="type">Type</button>
                        <button class="choice-btn font-bold py-1 px-3 rounded-md text-sm ui-action-button-secondary" data-choice="skip">Skip</button>
                    </div>
                `;
                chapterListContainer.appendChild(item);
            });
            
            chapterSelectionModal.classList.remove('hidden');
            loadingStatus.textContent = '';
        };

        // --- CHAPTER AND PARAGRAPH MANAGEMENT ---
        const countWords = (text) => {
            return text.split(/[\s-]+/).filter(w => w.length > 0).length;
        };

		function normalizeText(text, preserveDashes = false) {
			if (!text) return '';
			
			let normalized = text
				// ADD THIS NEW RULE to remove the specific invisible character (BOM/ZWNBSP)
				.replace(/\uFEFF/g, '')
				.replace(/[\u201C\u201D]/g, '"')      // Curly Double Quotes: “ ” → "
				.replace(/[«»]/g, '"')             // French Guillemets: « » → "
				.replace(/[\u2018\u2019]/g, "'")      // Curly Single Quotes: ‘ ’ → '
				.replace(/\u2026/g, '...')          // Ellipsis Character: … → ...
				.replace(/\.\s\.\s\./g, '...')   // Spaced Ellipsis: . . . → ...
				.replace(/\s+/g, ' ')              // Collapse multiple spaces into one
				.replace(/\u00A0/g, ' ');           // Replace non-breaking spaces with regular spaces

			// Only convert dashes if we are NOT preserving them
			if (!preserveDashes) {
				normalized = normalized.replace(/[\u2013\u2014]/g, '-'); // En & Em Dashes: – — → -
			}

			return normalized;
		}

		const startTypingBook = async (book) => { // Function is still async
			currentBookIdentifier = book.identifier;
			let fullBookData = null;

			// Try to fetch the full book data from IndexedDB (for new-format books)
			const bookDataFromDB = await getBookData(book.identifier);

			if (bookDataFromDB) {
				// If found, it's a new-format book. Combine metadata with the DB data.
				fullBookData = { ...book, ...bookDataFromDB };
			} else if (book.chapterMarkers) {
				// If not in the DB, it must be an old-format book with content still in localStorage.
				fullBookData = book;
			}

			// If content is not found in either place, then show an error.
			if (!fullBookData) {
				alert("Error: Could not find the book's content. Please try removing and re-adding the book.");
				return;
			}

			bookTitleHeader.innerHTML = `${fullBookData.bookName}<br><span class="text-3xl font-normal ui-accent-text" style="font-family: 'Cormorant Garamond', serif;">By ${fullBookData.author}</span>`;

			chapterMarkers = fullBookData.chapterMarkers.filter((marker, index) => {
				const choice = fullBookData.userChapterChoices[index];
				return choice && choice.status === 'type';
			});

			showTypingView(fullBookData);
			
			applySettings();
			
			updateDailyGoalDisplay();
			const today = new Date().toISOString().split('T')[0];
			const progress = loadDailyProgress();
			secondsPracticedToday = progress[today] || 0;

			const resumed = loadProgress();

			if (!resumed) {
				currentChapterIndex = 0;
				currentParagraphIndexInChapter = -1;
				bookContentEl.scrollTop = 0;
			}

			initializeChart();
			loadChapter(resumed ? currentChapterIndex : 0, resumed);
			populateChapterNavMenu();
		};

		const loadChapter = (chapterIndex, isResuming = false) => {
			if (chapterIndex >= chapterMarkers.length) {
				bookContentEl.innerHTML = `<h2 class="text-center text-green-400 text-3xl font-bold mt-8">Congratulations! You've finished all selected chapters.</h2>`;
				chapterStatsDisplay.textContent = '';
				return;
			}

			const isNewChapter = currentChapterIndex !== chapterIndex;
			currentChapterIndex = chapterIndex;

			const marker = chapterMarkers[currentChapterIndex];
			
			const chapterHtml = marker.htmlContent;
			const chapterHtmlCleaned = chapterHtml.replace(/<img[^>]*>/g, "");
			const tempDiv = document.createElement('div');
			tempDiv.innerHTML = chapterHtmlCleaned;

			let paragraphElements = Array.from(tempDiv.querySelectorAll('p'));
			if (paragraphElements.filter(p => (p.textContent || "").trim()).length < 3) {
				currentChapterParagraphs = (tempDiv.textContent || "")
					.split(/\n\s*\n+/)
					.map(text => text.trim())
					.filter(text => text.length > 0)
					.map(text => {
						const cleanText = normalizeText(text);
						return { html: cleanText, text: cleanText };
					});
			} else {
				currentChapterParagraphs = paragraphElements.map(p_el => {
					// 1. Get the inner HTML to preserve formatting tags like <i> and <em> for display.
					const paragraphHtml = p_el.innerHTML;
					// 2. Get the plain text for the typing comparison logic.
					const paragraphText = p_el.textContent || "";

					// 3. Normalize both versions, but handle dashes differently.
					// PRESERVE the em dash for the visual HTML version.
					const normalizedHtml = normalizeText(paragraphHtml, true); 
					// CONVERT the em dash to a simple hyphen for the typing logic version.
					const normalizedChars = normalizeText(paragraphText);
					// THEN, collapse any remaining/regular whitespace.
					const normalizedText = normalizedChars.replace(/\s+/g, ' ').trim();

					// 4. Store both the HTML (for display) and plain text (for logic) versions.
					return { html: normalizedHtml, text: normalizedText };
				}).filter(p => p.text.length > 0);
			}

			const chapterWordCount = countWords(currentChapterParagraphs.map(p => p.text).join(' '));
			currentChapterWordCount = chapterWordCount;
			
			const paragraphsDone = history.chapterIndices.filter(i => i === currentChapterIndex).length;
			paragraphCountDisplay.textContent = `${paragraphsDone} / ${currentChapterParagraphs.length}`;

			renderChapter(isResuming);

			if (isResuming) {
				const paragraphsDoneInChapter = history.chapterIndices.filter(i => i === currentChapterIndex).length;
				const lastValidIndex = Math.max(0, currentChapterParagraphs.length - 1);
				currentParagraphIndexInChapter = Math.min(paragraphsDoneInChapter, lastValidIndex);
				activateNextParagraph(false);
			} else {
				if (isNewChapter) currentParagraphIndexInChapter = -1;
				activateNextParagraph(true);
			}
		};

		const renderChapter = (isResuming) => {
			let html = '';
			if (!isDrillActive) {
				html += `<h2 class="chapter-heading text-3xl font-bold">${chapterMarkers[currentChapterIndex].title}</h2>`;
			}

			currentChapterParagraphs.forEach((p, index) => {
				const chars = wrapCharsInSpans(p.html);
				html += `<div class="paragraph-block" data-paragraph-index="${index}">${chars}<span class="end-cursor-target"></span></div>`;
			});
			currentContentEl.innerHTML = html;
			currentContentEl.scrollTop = 0;

			if (isResuming) {
				highlightCompletedParagraphs();
				updateChart();
			}
		};
		
		const renderDrill = () => {
			const drillText = currentChapterParagraphs[0].html;
			const chars = wrapCharsInSpans(drillText);
			drillContentEl.innerHTML = `<div class="paragraph-block" data-paragraph-index="0">${chars}<span class="end-cursor-target"></span></div>`;
			drillContentEl.scrollTop = 0;
		};

        const highlightCompletedParagraphs = () => {
		// Find all history entries that correspond to the current chapter
            const historyIndicesForChapter = history.chapterIndices
                .map((chapIdx, i) => ({ chapIdx, historyIndex: i }))
                .filter(item => item.chapIdx === currentChapterIndex);

            historyIndicesForChapter.forEach((item, paraIndexInChapter) => {
                const paragraphEl = document.querySelector(`[data-paragraph-index="${paraIndexInChapter}"]`);
                if (paragraphEl) {
                    const wasSkipped = history.wpm[item.historyIndex] === null;
                    const styleClass = wasSkipped ? 'char-span skipped' : 'char-span correct';
                    paragraphEl.querySelectorAll('.char-span').forEach(span => span.className = styleClass);
                }
            });
        };

		function resetParagraphHighlight(index) {
			const paragraphEl = currentContentEl.querySelector(`[data-paragraph-index="${index}"]`);
			if (paragraphEl) {
				paragraphEl.querySelectorAll('.char-span').forEach(span => span.className = 'char-span untyped');
			}
		}

		const activateNextParagraph = (shouldIncrement = true) => {
			resetParagraphState();

			if (shouldIncrement) {
				currentParagraphIndexInChapter++;
			}

			// Loop to skip any non-legitimate paragraphs (like dividers)
			while (
				currentParagraphIndexInChapter < currentChapterParagraphs.length &&
				!isParagraphLegitimate(currentParagraphIndexInChapter)
			) {
				// While skipping, find the paragraph on the screen and highlight it as correct.
				const paragraphToSkipEl = currentContentEl.querySelector(`[data-paragraph-index="${currentParagraphIndexInChapter}"]`);
				if (paragraphToSkipEl) {
					paragraphToSkipEl.querySelectorAll('.char-span').forEach(span => span.className = 'char-span correct');
				}
				currentParagraphIndexInChapter++; // Move to the next one to check
			}

			// After the loop, check if we've reached the end of the chapter
			if (currentParagraphIndexInChapter >= currentChapterParagraphs.length) {
				loadChapter(currentChapterIndex + 1);
				return;
			}

			// If we've found a legitimate paragraph, activate it for typing
			const paragraphEl = currentContentEl.querySelector(`[data-paragraph-index="${currentParagraphIndexInChapter}"]`);
			if (paragraphEl) {
				const topPos = paragraphEl.getBoundingClientRect().top - currentContentEl.getBoundingClientRect().top + currentContentEl.scrollTop;
				currentContentEl.scrollTop = topPos;

				currentParagraphSpans = Array.from(paragraphEl.querySelectorAll('.char-span'));
				
				if (currentCursorSpan) currentCursorSpan.classList.remove('cursor');
				if (currentParagraphSpans.length > 0) {
					currentCursorSpan = currentParagraphSpans[0];
					currentCursorSpan.classList.add('cursor');
				}
				
				hiddenInput.focus();
			}
		};

        const skipParagraph = () => {
		    stopDailyProgressTimer();
			// Highlight the skipped paragraph
            const paragraphEl = document.querySelector(`[data-paragraph-index="${currentParagraphIndexInChapter}"]`);
            if (paragraphEl) {
                paragraphEl.querySelectorAll('.char-span').forEach(span => span.className = 'char-span skipped');
            }

            history.wpm.push(null); // Using null indicates a skip
            history.accuracy.push(null);
            history.labels.push(`S${history.labels.length + 1}`); // "S" for Skipped
    
            history.rawTimes.push(0);
            history.rawCorrectChars.push(0);
            history.rawTypedChars.push(0);

            const lastOverallWpm = history.overallWpmHistory.length > 0 ? history.overallWpmHistory[history.overallWpmHistory.length - 1] : 0;
            history.overallWpmHistory.push(lastOverallWpm);
            history.cumulativeWords.push(overallStats.cumulativeWordCount); // Word count doesn't increase

			// Record the location
            history.chapterIndices.push(currentChapterIndex);
    
            const lastCumulativeWordsInChapter = history.cumulativeWordsInChapter.length > 0 ? history.cumulativeWordsInChapter[history.cumulativeWordsInChapter.length-1] : 0;
            history.cumulativeWordsInChapter.push(lastCumulativeWordsInChapter);
            history.paragraphWordCounts.push(0); // 0 words were contributed

			// Update the UI
            const paragraphsDone = history.chapterIndices.filter(i => i === currentChapterIndex).length;
            paragraphCountDisplay.textContent = `${paragraphsDone} / ${currentChapterParagraphs.length}`;
            updateChart(); // This will register the "null" data point, creating a gap in the chart

			// Move to the next paragraph
			if (currentParagraphIndexInChapter === currentChapterParagraphs.length - 1) {
				// This was the last paragraph!
				console.log("Chapter complete!");
				triggerFullscreenConfetti();
			}
            activateNextParagraph(true);
            saveProgress();
        };

        // --- TYPING LOGIC ---

        const resetParagraphState = () => {
            isTestActive = false;
            paragraphKeyPressLog = [];
            liveAccuracyLog = [];
            currentUserInput = '';
			hiddenInput.value = '';
			currentParagraphAnalysis = {
			    bigrams: {},
				trigrams: {},
				entryDelays: {}
			};
        };
		
		const logKeyPressAnalysis = (key, isCorrect) => {
			const isLetter = /^[a-zA-Z]$/.test(key);
			if (!isLetter) return;

			const log = paragraphKeyPressLog;
			const input = currentUserInput;
			const analysis = currentParagraphAnalysis;

			let lastTimestamp = log.length > 0 ? log[log.length - 1].time : 0;
			const delay = lastTimestamp ? Date.now() - lastTimestamp : 0;

			const charIndex = input.length;

			// 1. Analyze Bigrams
			if (charIndex >= 1) {
				const prevChar = input[charIndex - 1];
				if (/^[a-zA-Z]$/.test(prevChar)) {
					const rawBigram = `${prevChar}${key}`;
					const bigram = rawBigram.toLowerCase();

					if (!analysis.bigrams[bigram] || !analysis.bigrams[bigram].events) {
						analysis.bigrams[bigram] = { delays: [], errors: 0 };
					}
					// Only log the delay if no capital letters were involved
					if (!/[A-Z]/.test(rawBigram)) {
						analysis.bigrams[bigram].delays.push(delay);
					}
					if (!isCorrect) {
						analysis.bigrams[bigram].errors++;
					}

					// 2. Analyze Entry Delay
					const charBefore = input[charIndex - 2] || ' ';
					if (charBefore === ' ') {
						const firstLetter = prevChar.toLowerCase();
						if (!analysis.entryDelays[firstLetter]) {
							analysis.entryDelays[firstLetter] = [];
						}
						const lastSpaceEvent = log.slice().reverse().find(e => e.char === ' ');
						if (lastSpaceEvent) {
							const entryDelay = log[log.length - 1].time - lastSpaceEvent.time;
							analysis.entryDelays[firstLetter].push(entryDelay);
						}
					}
				}
			}

			// 3. Analyze Trigrams
			if (charIndex >= 2) {
				const prevChar1 = input[charIndex - 2];
				const prevChar2 = input[charIndex - 1];
				if (/^[a-zA-Z]$/.test(prevChar1) && /^[a-zA-Z]$/.test(prevChar2)) {
					const rawTrigram = `${prevChar1}${prevChar2}${key}`;
					const trigram = rawTrigram.toLowerCase();

					if (!analysis.trigrams[trigram] || !analysis.trigrams[trigram].events) {
						analysis.trigrams[trigram] = { delays: [], errors: 0 };
					}
					// Only log the delay if no capital letters were involved
					if (!/[A-Z]/.test(rawTrigram)) {
						const delay2 = log[log.length - 1].time - log[log.length - 2].time;
						analysis.trigrams[trigram].delays.push(delay + delay2);
					}
					 if (!isCorrect) {
						analysis.trigrams[trigram].errors++;
					}
				}
			}
		};

        const startTest = () => {
            isTestActive = true;
			if (!dailyProgressTimer) { // Only start if it's not already running
				paragraphStartTime = Date.now();
				dailyProgressTimer = setInterval(updateLiveTimer, 1000);
			}
        };

		const handleKeyPress = (e) => {
			
			const activeEl = document.activeElement;
			if (activeEl && (activeEl.tagName === 'INPUT' && activeEl.id !== 'hidden-input') || activeEl.tagName === 'TEXTAREA' || activeEl.isContentEditable) {
				return; // Ignore keypresses in other input fields
			}
			
			paragraphKeyPressLog.push({ key: e.key, time: Date.now() });

			if (isBookLoading) {
				e.preventDefault();
				return;
			}

			if (currentParagraphIndexInChapter < 0 || currentParagraphIndexInChapter >= currentChapterParagraphs.length) return;

			// --- Control Key Logic ---
			if (e.key === 'Enter') {
				e.stopPropagation();
				if (isDrillActive) return;
				if (e.shiftKey) { skipParagraph(); return; }
				if (isTestActive) {
					finishParagraph();
				}
				return;
			} 
			
			if (e.key === 'Tab') {
				e.preventDefault();
				if (e.shiftKey) {
					stopDailyProgressTimer();
					resetParagraphHighlight(currentParagraphIndexInChapter);
					goToPreviousParagraph();

					return;
				}
				stopDailyProgressTimer();
				resetParagraphState();
				resetParagraphHighlight(currentParagraphIndexInChapter);
				activateNextParagraph(false);
			}
		};

        // --- UI & STATS UPDATES ---
		
		function formatNavTitle(title) {
			const maxLength = 25;
			if (title.length > maxLength) {
				return title.substring(0, 22) + '...';
			}
			return title;
		}

		function handleInput(e) {
			if (!isTestActive && hiddenInput.value.length > 0) {
				startTest();
			}

			const newText = hiddenInput.value;
			const sourceText = currentChapterParagraphs[currentParagraphIndexInChapter].text;

			if (newText.length > sourceText.length) {
				hiddenInput.value = newText.substring(0, sourceText.length);
				return;
			}

			currentUserInput = hiddenInput.value;

			// Schedule a single, efficient update instead of updating on every keystroke
			if (!isUpdateScheduled) {
				isUpdateScheduled = true;
				requestAnimationFrame(() => {
					updateHighlighting();
					updateCursor();
					updateLiveStats();
					
					// Auto-finish logic for drills
					const sourceText = currentChapterParagraphs[currentParagraphIndexInChapter].text;

					if (currentUserInput.slice(-1) === ' ' || currentUserInput.length === sourceText.length) {
						checkAndScrollCursorIntoView();
					}

					// Auto-finish logic for drills
					if (isDrillActive && currentUserInput.length === drillTargetLength) {
						finishDrill();
					}

					isUpdateScheduled = false; // Allow the next update to be scheduled
				});
			}
		}
		
		const updateLiveStats = () => {
			if (!isTestActive || !paragraphStartTime) return;

			const timeElapsed = (Date.now() - paragraphStartTime) / 1000;
			if (timeElapsed <= 0) return;

			const typedChars = currentUserInput.length;

			// Calculate WPM
			const wpm = (typedChars / CHARS_PER_WORD) / (timeElapsed / 60);

			// Calculate Accuracy
			const sourceText = currentChapterParagraphs[currentParagraphIndexInChapter].text;
			let correctChars = 0;
			for (let i = 0; i < typedChars; i++) {
				if (currentUserInput[i] === sourceText[i]) correctChars++;
			}
			const accuracy = typedChars > 0 ? (correctChars / typedChars) * 100 : 100;

			// Update the displays for the current mode (book or drill)
			if (isDrillActive) {
				drillWpmDisplay.textContent = Math.round(wpm);
				drillAccuracyDisplay.textContent = `${Math.round(accuracy)}%`;
			} else {
				liveWpmDisplay.textContent = Math.round(wpm);
				liveAccuracyDisplay.textContent = `${Math.round(accuracy)}%`;
			}
		};

		let dailyGoalChart;
		
		function updateDailyProgress(secondsToAdd) {
			const today = new Date().toISOString().split('T')[0];
			const progress = loadDailyProgress();
			
			// Get the time BEFORE adding the new value
			const timeBeforeUpdate = progress[today] || 0;
			const newTime = timeBeforeUpdate + secondsToAdd;
			progress[today] = newTime;
			saveDailyProgress(progress);

			// Check if the goal was just crossed
			const dailyGoalSeconds = (loadSettings().dailyGoalInMinutes || 30) * 60;
			if (timeBeforeUpdate < dailyGoalSeconds && newTime >= dailyGoalSeconds) {
				console.log("Daily goal reached!");
				confetti();
			}

			// Now update the UI
			updateDailyGoalDisplay();
		}

		function initializeDailyGoalChart() {
			const ctx = document.getElementById('daily-goal-chart').getContext('2d');
			const themeStyles = getComputedStyle(document.body);
			const accentColor = themeStyles.getPropertyValue('--theme-ui-accent').trim();
			const bgColor = themeStyles.getPropertyValue('--theme-ui-bg').trim();

			dailyGoalChart = new Chart(ctx, {
				type: 'doughnut',
				data: {
					datasets: [{
						data: [0, 100], // [Progress, Remainder]
						backgroundColor: [accentColor, bgColor],
						borderWidth: 0
					}]
				},
				options: {
					responsive: true,
					cutout: '70%',
					plugins: { tooltip: { enabled: false } },
					events: [] // Disable all events on the chart
				}
			});
		}

		function updateDailyGoalDisplay(liveSecondsPracticed) {
			const settings = loadSettings(); 
			const dailyGoalSeconds = (settings.dailyGoalInMinutes || 30) * 60;

			// If liveSecondsPracticed is provided, use it. Otherwise, use the stored value.
			const secondsPracticed = liveSecondsPracticed !== undefined ? liveSecondsPracticed : secondsPracticedToday;
			
			const minutesPracticed = Math.floor(secondsPracticed / 60);
			const percentComplete = Math.min(100, (secondsPracticed / dailyGoalSeconds) * 100);

			const progressBar = document.getElementById('daily-progress-bar');
			const goalTextEl = document.getElementById('daily-goal-text');

			if (progressBar) {
				progressBar.style.width = `${percentComplete}%`;
			}
			if (goalTextEl) {
				goalTextEl.textContent = `${minutesPracticed}/${settings.dailyGoalInMinutes || 30} min (${Math.floor(percentComplete)}%)`;
			}
		}
		
		const finishParagraph = () => {
			stopDailyProgressTimer();
			const sourceText = currentChapterParagraphs[currentParagraphIndexInChapter].text;

			// Guard clause: Only finish if the test was actually active and a start time was recorded.
			if (!isTestActive || !paragraphStartTime) {
				activateNextParagraph();
				return;
			};

			const timeElapsed = (Date.now() - paragraphStartTime) / 1000;
			
			let correctChars = 0;
			for (let i = 0; i < currentUserInput.length; i++) {
				if (sourceText[i] === currentUserInput[i]) correctChars++;
			}
			const typedChars = currentUserInput.length;
			const paragraphWPM = ((typedChars / CHARS_PER_WORD) / (timeElapsed / 60)) || 0;
			const paragraphAccuracy = typedChars > 0 ? (correctChars / typedChars) * 100 : 0;

			const paragraphWordCount = countWords(sourceText);
			history.rawTimes.push(timeElapsed);
			history.rawCorrectChars.push(correctChars);
			history.rawTypedChars.push(typedChars);
			history.paragraphWordCounts.push(paragraphWordCount);
			history.chapterIndices.push(currentChapterIndex);
			
			if (!history.timestamps) history.timestamps = [];
			history.timestamps.push(Date.now());

			let currentChapterCumulative = 0;
			for (let i = 0; i < history.paragraphWordCounts.length; i++) {
				if (history.chapterIndices[i] === currentChapterIndex) {
					currentChapterCumulative += history.paragraphWordCounts[i];
				}
			}
			history.cumulativeWordsInChapter.push(currentChapterCumulative);
			overallStats.cumulativeWordCount += paragraphWordCount;
			overallStats.totalCorrectChars += correctChars;
			overallStats.totalTypedChars += typedChars;
			overallStats.totalTime += timeElapsed;
			const overallWPM = ((overallStats.totalTypedChars / CHARS_PER_WORD) / (overallStats.totalTime / 60)) || 0;
			const newCount = history.labels.length + 1;
			history.wpm.push(paragraphWPM);
			history.accuracy.push(paragraphAccuracy);
			history.overallWpmHistory.push(overallWPM);
			history.cumulativeWords.push(overallStats.cumulativeWordCount);
			history.labels.push(`P${newCount}`);
			paragraphCountDisplay.textContent = `${history.chapterIndices.filter(i => i === currentChapterIndex).length} / ${currentChapterParagraphs.length}`;
			performPostParagraphAnalysis();
			analyzeAndSaveParagraphStats();
			updateChart();
			if (currentParagraphIndexInChapter === currentChapterParagraphs.length - 1) {
				console.log("Chapter complete!");
				triggerFullscreenConfetti();
			}
			activateNextParagraph();
			saveProgress();
		};

		const goToPreviousParagraph = () => {
            // Check if there's any history to go back to.
            if (history.wpm.length === 0) return;

            // 1. Get info about the last completed paragraph BEFORE modifying history.
            const chapterOfLastParagraph = history.chapterIndices[history.chapterIndices.length - 1];
            
            // 2. Calculate the index (within its chapter) of the paragraph we want to redo.
            // This is the number of paragraphs from that chapter already in the history, minus one.
            const paragraphIndexToGoTo = history.chapterIndices.filter(i => i === chapterOfLastParagraph).length - 1;

			for (let i = currentParagraphIndexInChapter - 1; i > paragraphIndexToGoTo; i--) {
				if (!isParagraphLegitimate(i)) {
					resetParagraphHighlight(i);
				}
			}

            // 3. Get the raw stats for the paragraph to be "undone".
            const lastWordCount = history.paragraphWordCounts[history.paragraphWordCounts.length - 1];
            const lastTime = history.rawTimes[history.rawTimes.length - 1];
            const lastCorrectChars = history.rawCorrectChars[history.rawCorrectChars.length - 1];
            const lastTypedChars = history.rawTypedChars[history.rawTypedChars.length - 1];

            // 4. Pop all data for the last paragraph from history.
            history.wpm.pop();
            history.accuracy.pop();
            history.labels.pop();
            history.overallWpmHistory.pop();
            history.cumulativeWords.pop();
            history.chapterIndices.pop();
            history.paragraphWordCounts.pop();
            history.cumulativeWordsInChapter.pop();
            history.rawTimes.pop();
            history.rawCorrectChars.pop();
            history.rawTypedChars.pop();
            if (history.timestamps) history.timestamps.pop();

            // 5. Decrement overall stats.
            overallStats.totalTime -= lastTime;
            overallStats.totalCorrectChars -= lastCorrectChars;
            overallStats.totalTypedChars -= lastTypedChars;
            overallStats.cumulativeWordCount -= lastWordCount;
            
            // 6. Handle UI and state transition.
            const chapterNeedsReload = currentChapterIndex !== chapterOfLastParagraph;
            currentChapterIndex = chapterOfLastParagraph;
            currentParagraphIndexInChapter = paragraphIndexToGoTo;

            if (chapterNeedsReload) {
                // loadChapter will render the chapter, highlight completed paragraphs, and activate the correct one.
                loadChapter(currentChapterIndex, true);
            } else {
                // If we are in the same chapter, manually reset the styling of the target paragraph.
                const paragraphEl = document.querySelector(`[data-paragraph-index="${currentParagraphIndexInChapter}"]`);
                if (paragraphEl) {
                    paragraphEl.querySelectorAll('.char-span').forEach(span => {
                        span.className = 'char-span untyped';
                    });
                }
                // Then, activate it. This will reset the paragraph's typing state and move the cursor.
                activateNextParagraph(false);
            }

            // 7. Update all stats displays.
            const overallWPM = overallStats.totalTime > 0 ? ((overallStats.totalTypedChars / CHARS_PER_WORD) / (overallStats.totalTime / 60)) : 0;
            const overallAccuracy = overallStats.totalTypedChars > 0 ? Math.round((overallStats.totalCorrectChars / overallStats.totalTypedChars) * 100) : 100;
            
            const paragraphsDone = history.chapterIndices.filter(i => i === currentChapterIndex).length;
            paragraphCountDisplay.textContent = `${paragraphsDone} / ${currentChapterParagraphs.length}`;

            updateChart();
            saveProgress();
        };

		const updateHighlighting = () => {
			if (currentParagraphIndexInChapter < 0 || !currentChapterParagraphs[currentParagraphIndexInChapter]) {
				return; // Do nothing if the state isn't ready.
			}

			const sourceText = currentChapterParagraphs[currentParagraphIndexInChapter].text;
			const inputLength = currentUserInput.length;

			currentParagraphSpans.forEach((span, i) => {
				let newClassName;

				// Determine what the new class SHOULD be
				if (i < inputLength) {
					newClassName = currentUserInput[i] === sourceText[i] 
						? 'char-span correct' 
						: 'char-span incorrect-char';
				} else {
					newClassName = 'char-span untyped';
				}

				// The performance optimization: Only update the DOM if the class has changed.
				if (span.className !== newClassName) {
					span.className = newClassName;
				}
			});
		};

		const updateCursor = () => {
			if (currentCursorSpan) {
				currentCursorSpan.classList.remove('cursor');
			}

			const cursorPosition = currentUserInput.length;

			if (cursorPosition < currentParagraphSpans.length) {
				currentCursorSpan = currentParagraphSpans[cursorPosition];
				currentCursorSpan.classList.add('cursor');
			} else {
				// Handle cursor at the end of the paragraph
				currentCursorSpan = null; 
				const paragraphEl = currentContentEl.querySelector(`[data-paragraph-index="${currentParagraphIndexInChapter}"]`);
				if (paragraphEl) { // Added a check to prevent errors
					const endTarget = paragraphEl.querySelector('.end-cursor-target');
					if (endTarget) endTarget.classList.add('cursor');
				}
			}
		};

        // --- CHART LOGIC ---
        const getChapterColor = (chapterIndex) => {
            const hue = (chapterIndex * 40) % 360;
            return `hsla(${hue}, 60%, 50%, 0.6)`;
        };

		const initializeChart = () => {
			const ctx = document.getElementById('history-chart').getContext('2d');
			if (historyChart) {
				historyChart.destroy();
			}

			const themeStyles = getComputedStyle(document.body);
			const textColor = themeStyles.getPropertyValue('--theme-ui-medium').trim() || '#d1d5db';
			const gridColor = 'rgba(255, 255, 255, 0.1)';

			historyChart = new Chart(ctx, {
				data: { labels: [], datasets: [{ type: 'bar', label: 'Paragraph WPM', data: [], yAxisID: 'y' }] },
				options: {
					responsive: true,
					interaction: { mode: 'index', intersect: false },
					scales: {
						x: { type: 'category', title: { display: true, text: 'Words Typed in Chapter', color: textColor }, grid: { color: gridColor }, ticks: { color: textColor } },
						y: { type: 'linear', display: true, position: 'left', title: { display: true, text: 'WPM', color: textColor }, grid: { color: gridColor }, ticks: { color: textColor }, beginAtZero: true }
					},
					plugins: { 
						legend: { labels: { color: textColor }},
						tooltip: {
							callbacks: {
								title: function(context) {
									// Use the custom label like "P1", "P2", etc. as the title
									const index = context[0].dataIndex;
									return `Paragraph ${context[0].label.replace('P', '')}`;
								},
								label: function(context) {
									// Get the WPM value for the hovered bar directly from the chart's dataset.
									const wpm = context.raw;
									const index = context.dataIndex;

									// Check if the bar has data. If wpm is null, it's an untyped or skipped paragraph.
									if (wpm === null) {
										// Check our history array to see if it was explicitly skipped.
										if (history.wpm[index] === null) {
											return '  Skipped';
										}
										return ''; // Otherwise, it's just an untyped paragraph, so show no label body.
									}

									// If we have a WPM value, get the corresponding accuracy from our history array.
									const accuracy = history.accuracy[index];

									// Format the output. The toFixed() call is now safe.
									return [
										`  WPM: ${wpm.toFixed(1)}`,
										`  Accuracy: ${accuracy !== undefined ? accuracy.toFixed(0) : '--'}%`
									];
								}
							}
						}
					}
				}
			});
		};

		const updateChart = () => {
			if (!historyChart) return;

			const themeStyles = getComputedStyle(document.body);
			const barColor = themeStyles.getPropertyValue('--theme-ui-medium').trim() || '#60a5fa';
			const textColor = themeStyles.getPropertyValue('--theme-ui-bright').trim() || '#d1d5db';

			// Update chart colors based on theme
			historyChart.options.scales.x.title.color = textColor;
			historyChart.options.scales.x.ticks.color = textColor;
			historyChart.options.scales.y.title.color = textColor;
			historyChart.options.scales.y.ticks.color = textColor;
			historyChart.options.plugins.legend.labels.color = textColor;

			if (isShowingAllHistory) {
				// --- "Entire Book" View Logic ---
				const totalChapters = chapterMarkers.length;
				
				// 1. Create placeholder arrays for all chapters in the book.
				historyChart.data.labels = chapterMarkers.map((cm, i) => `Ch. ${i + 1}`);
				const chapterWpmData = Array(totalChapters).fill(null);

				// 2. Group all history entries by the chapter they belong to.
				const historyByChapter = history.wpm.reduce((acc, wpm, i) => {
					const chapIdx = history.chapterIndices[i];
					if (wpm !== null) { // Only count typed paragraphs, not skipped ones
						if (!acc[chapIdx]) acc[chapIdx] = [];
						acc[chapIdx].push(wpm);
					}
					return acc;
				}, {});
				
				// 3. Calculate the average WPM for each chapter and populate the data array.
				for (const chapIdx in historyByChapter) {
					const chapterWpms = historyByChapter[chapIdx];
					if (chapterWpms.length > 0) {
						const avgWpm = chapterWpms.reduce((sum, wpm) => sum + wpm, 0) / chapterWpms.length;
						chapterWpmData[chapIdx] = avgWpm;
					}
				}
				
				historyChart.data.datasets[0].data = chapterWpmData;
				historyChart.data.datasets[0].backgroundColor = barColor;
				historyChart.data.datasets[0].label = 'Chapter Avg. WPM';
				historyChart.options.scales.x.title.text = 'Chapters in Book';

			} else {
				// --- "Current Chapter" View Logic ---
				const totalParagraphs = currentChapterParagraphs.length;

				// 1. Create placeholder arrays for all paragraphs in the current chapter.
				historyChart.data.labels = Array.from({ length: totalParagraphs }, (_, i) => `P${i + 1}`);
				const paragraphWpmData = Array(totalParagraphs).fill(null);

				// 2. Find all the history entries that belong to this chapter.
				let paragraphInChapterCounter = 0;
				for (let i = 0; i < history.chapterIndices.length; i++) {
					if (history.chapterIndices[i] === currentChapterIndex) {
						// 3. Fill in the data for the completed paragraphs at the correct index.
						paragraphWpmData[paragraphInChapterCounter] = history.wpm[i];
						paragraphInChapterCounter++;
					}
				}
				
				historyChart.data.datasets[0].data = paragraphWpmData;
				historyChart.data.datasets[0].backgroundColor = barColor;
				historyChart.data.datasets[0].label = 'Paragraph WPM';
				historyChart.options.scales.x.title.text = 'Paragraphs in Chapter';
			}

			const allWpms = history.wpm.filter(w => w !== null);
			if (allWpms.length > 0) {
				const maxWpm = Math.max(...allWpms);
				historyChart.options.scales.y.min = 0;
				historyChart.options.scales.y.max = Math.ceil(maxWpm * 1.20);
			} else {
				historyChart.options.scales.y.min = 0;
				historyChart.options.scales.y.max = 100;
			}

			historyChart.update();
		};

		function performPostParagraphAnalysis() {
			currentParagraphAnalysis = { bigrams: {}, trigrams: {} };
			const sourceText = currentChapterParagraphs[currentParagraphIndexInChapter].text;
			const rawLog = paragraphKeyPressLog;

			let virtualCursorPos = 0;
			const correctTimings = []; // Log of {key, time} for only the final, correct keypresses

			// --- Part 1: Analyze the full journey for ERRORS ---
			for (const event of rawLog) {
				if (event.key.length === 1) { // A character was typed
					if (virtualCursorPos < sourceText.length) {
						const isCorrect = event.key === sourceText[virtualCursorPos];
						if (!isCorrect) {
							// An error occurred! Log it against the n-gram that SHOULD have been typed.
							// Log bigram error
							if (virtualCursorPos > 0) {
								const bigram = (sourceText[virtualCursorPos - 1] + sourceText[virtualCursorPos]).toLowerCase();
								if (MASTER_BIGRAMS_200.includes(bigram)) {
									if (!currentParagraphAnalysis.bigrams[bigram]) currentParagraphAnalysis.bigrams[bigram] = { delays: [], errors: 0 };
									currentParagraphAnalysis.bigrams[bigram].errors++;
								}
							}
							// Log trigram error
							if (virtualCursorPos > 1) {
								const trigram = (sourceText[virtualCursorPos - 2] + sourceText[virtualCursorPos - 1] + sourceText[virtualCursorPos]).toLowerCase();
								if (MASTER_TRIGRAMS_200.includes(trigram)) {
									if (!currentParagraphAnalysis.trigrams[trigram]) currentParagraphAnalysis.trigrams[trigram] = { delays: [], errors: 0 };
									currentParagraphAnalysis.trigrams[trigram].errors++;
								}
							}
						}
					}
					virtualCursorPos++;
				} else if (event.key === 'Backspace') {
					virtualCursorPos = Math.max(0, virtualCursorPos - 1);
				}
			}

			// --- Part 2: Analyze the final, correct keystrokes for SPEED ---
			// First, build a clean log of the final keypresses by simulating the typing journey
			for (const event of rawLog) {
				if (event.key.length === 1) {
					correctTimings.push(event);
				} else if (event.key === 'Backspace') {
					if (correctTimings.length > 0) correctTimings.pop();
				}
			}

			// Now, calculate delays from the clean timing log
			if (correctTimings.length >= 2) {
				for (let i = 1; i < correctTimings.length; i++) {
					const char = correctTimings[i].key;
					const prevChar = correctTimings[i-1].key;
					
					// Bigram Speed
					const bigram = (prevChar + char).toLowerCase();
					if (MASTER_BIGRAMS_200.includes(bigram)) {
						if (!currentParagraphAnalysis.bigrams[bigram]) currentParagraphAnalysis.bigrams[bigram] = { delays: [], errors: 0 };
						const delay = correctTimings[i].time - correctTimings[i-1].time;
						currentParagraphAnalysis.bigrams[bigram].delays.push(delay);
					}

					// Trigram Speed
					if (i > 1) {
						const prevChar2 = correctTimings[i-2].key;
						const trigram = (prevChar2 + prevChar + char).toLowerCase();
						 if (MASTER_TRIGRAMS_200.includes(trigram)) {
							if (!currentParagraphAnalysis.trigrams[trigram]) currentParagraphAnalysis.trigrams[trigram] = { delays: [], errors: 0 };
							const delay = correctTimings[i].time - correctTimings[i-2].time;
							currentParagraphAnalysis.trigrams[trigram].delays.push(delay);
						}
					}
				}
			}
		}

		function wrapCharsInSpans(htmlString) {
			const tempDiv = document.createElement('div');
			tempDiv.innerHTML = htmlString;

			function processNode(node) {
				// If it's an element (like <i> or <em>), we process its children
				if (node.nodeType === Node.ELEMENT_NODE) {
					// Create a copy of the children array because the collection is live
					const children = Array.from(node.childNodes);
					children.forEach(processNode);
				}
				// If it's a text node, we wrap its characters in spans
				else if (node.nodeType === Node.TEXT_NODE) {
					const text = node.textContent;
					const fragment = document.createDocumentFragment();
					for (const char of text) {
						const span = document.createElement('span');
						span.className = 'char-span untyped';
						span.textContent = char;
						fragment.appendChild(span);
					}
					node.parentNode.replaceChild(fragment, node);
				}
			}

			processNode(tempDiv);
			return tempDiv.innerHTML;
		}
		
		// --- Chapter Navigation Menu Logic ---

		function populateChapterNavMenu() {
			navChapterMenu.innerHTML = '';
			chapterMarkers.forEach((marker, index) => {
				const chapterItem = document.createElement('button');
				chapterItem.className = 'block w-full text-left p-2 rounded-md ui-secondary-text hover:ui-bright-text';
				chapterItem.textContent = marker.title;
				chapterItem.dataset.index = index;
				if (index === currentChapterIndex) {
					chapterItem.classList.add('ui-bright-text');
					chapterItem.classList.remove('ui-secondary-text');
				}
				navChapterMenu.appendChild(chapterItem);
			});
		}

		navBookTitleBtn.addEventListener('click', (e) => {
			e.stopPropagation(); // Prevents the window click listener from firing immediately
			navChapterMenu.classList.toggle('hidden');
		});

		navChapterMenu.addEventListener('click', (e) => {
			const target = e.target.closest('button');
			if (target && target.dataset.index) {
				const newChapterIndex = parseInt(target.dataset.index);
				if (newChapterIndex !== currentChapterIndex) {
					loadChapter(newChapterIndex);
					populateChapterNavMenu(); // Re-populate to update the highlight
				}
				navChapterMenu.classList.add('hidden');
			}
		});

		// Hide the menu if clicking outside of it
		window.addEventListener('click', () => {
			if (!navChapterMenu.classList.contains('hidden')) {
				navChapterMenu.classList.add('hidden');
			}
		});

        // --- EVENT LISTENERS ---
        document.addEventListener('DOMContentLoaded', setupUser);
        changeUserBtn.addEventListener('click', () => { showLibraryView(); showProfileSwitcher(); });

        // Profile Creation Listeners
        saveProfileBtn.addEventListener('click', saveNewProfile);
        if (cancelCreateProfileBtn) {
            cancelCreateProfileBtn.addEventListener('click', () => {
                profileModal.classList.add('hidden');
                if (getProfiles().length > 0) {
                    showProfileSwitcher();
                }
            });
        }
		
		// --- Navigation Bar Listeners ---
		navTypingBtn.addEventListener('click', () => {
			if (isDrillActive) cleanupDrillState();
			const library = getLibrary();
			const currentBook = library.find(b => b.identifier === currentBookIdentifier);
			if (currentBook) {
				showTypingView(currentBook);
				loadChapter(currentChapterIndex, true); 
			}
		});
		
        navLibraryBtn.addEventListener('click', () => {
            if (isDrillActive) cleanupDrillState();
			if (isTestActive) {
                saveProgress();
            }
            stopDailyProgressTimer();
            showLibraryView();
        });

		navReportsBtn.addEventListener('click', () => {
            if (isDrillActive) cleanupDrillState();
            const library = getLibrary();
            const currentBook = library.find(b => b.identifier === currentBookIdentifier);
            if (currentBook) {
                showReportsView(currentBook);
                const fullReportViewEl = document.getElementById('full-report-view');
                // If the user is navigating here and the full report is what's showing,
                // then force it to refresh its data.
                if (!fullReportViewEl.classList.contains('hidden')) {
                    displayFullReport();
                }
            }
			
        });
        navSettingsBtn.addEventListener('click', () => {
            populateSettingsModal();
            settingsModal.classList.remove('hidden');
        });

        navChangeUserBtn.addEventListener('click', () => {
            showLibraryView();
            showProfileSwitcher();
        });
        
        // Profile Switcher Listeners
        profileSwitcherModal.addEventListener('click', (e) => {
            const loadBtn = e.target.closest('.load-profile-btn');
            const deleteBtn = e.target.closest('.delete-profile-btn');
            if (loadBtn) { loadProfile(loadBtn.dataset.username); }
            if (deleteBtn) { deleteProfile(deleteBtn.dataset.username); }
        });
        showCreateProfileBtn.addEventListener('click', () => {
            profileSwitcherModal.classList.add('hidden');
            profileModal.classList.remove('hidden');
        });
        
        // Book Adding and Chapter Selection Listeners
        addNewBookBtn.addEventListener('click', showFileLoaderView);
        backToLibraryBtn.addEventListener('click', showLibraryView);
        localFileInput.addEventListener('change', (e) => { if (e.target.files.length > 0) handleFile(e.target.files[0]); });
        cancelAddBookBtn.addEventListener('click', () => { tempBookData = {}; chapterSelectionModal.classList.add('hidden'); showFileLoaderView(); });

        // Typing View Listeners
		
		hiddenInput.addEventListener('input', handleInput);
		bookContentEl.addEventListener('click', () => hiddenInput.focus());
        document.addEventListener('keydown', handleKeyPress);
        chartToggleButton.addEventListener('click', () => { isShowingAllHistory = !isShowingAllHistory; chartToggleButton.textContent = isShowingAllHistory ? 'Show Current Chapter' : 'Show Entire Book'; updateChart(); });

        // --- Drag and Drop Event Listeners ---
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('drag-over');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
            if (e.dataTransfer.files.length > 0) {
                handleFile(e.dataTransfer.files[0]);
            }
        });

		chapterListContainer.addEventListener('click', (e) => {
            if (e.target.classList.contains('choice-btn')) {
                const choice = e.target.dataset.choice;
                const buttonGroup = e.target.parentElement;
                
                // Reset both buttons in the group to the inactive state
                buttonGroup.querySelectorAll('.choice-btn').forEach(btn => {
                    btn.classList.remove('choice-btn-active', 'ui-action-button-primary');
					btn.classList.add('ui-action-button-secondary');
                });

                // Apply the active state to the clicked button
                e.target.classList.remove('ui-action-button-secondary');
                e.target.classList.add('choice-btn-active', 'ui-action-button-primary');
            }
        });

		saveChaptersBtn.addEventListener('click', async () => {
			const choices = [];
			chapterListContainer.querySelectorAll('.flex.space-x-2').forEach(group => {
				const index = group.dataset.index;
				const activeButton = group.querySelector('.choice-btn-active');
				const status = activeButton ? activeButton.dataset.choice : 'type';
				choices[index] = { status };
			});

			// 1. Prepare the large book file for IndexedDB
			const bookFileForDB = {
				id: tempBookData.identifier,
				cover: tempBookData.cover,
				chapterMarkers: tempBookData.chapterMarkers
			};

			// 2. Prepare the small metadata object for localStorage
			const bookMetadataForLocal = {
				bookName: tempBookData.title,
				author: tempBookData.author,
				identifier: tempBookData.identifier,
				userChapterChoices: choices
			};

			try {
				// 3. Save the large file to our new database
				await saveBookData(bookFileForDB);

				// 4. If successful, update and save the metadata library to localStorage
				const library = getLibrary();
				library.push(bookMetadataForLocal);
				saveLibrary(library);

				// 5. Clean up the UI
				tempBookData = {};
				chapterSelectionModal.classList.add('hidden');
				showLibraryView();
				renderLibrary();

			} catch (error) {
				console.error("Failed to save book to IndexedDB:", error);
				alert("There was an error saving the book's content. Please try again.");
			}
		});
        
        cancelAddBookBtn.addEventListener('click', () => {
            tempBookData = {};
            chapterSelectionModal.classList.add('hidden');
            showFileLoaderView();
        });

        closeSettingsBtn.addEventListener('click', () => {
            settingsModal.classList.add('hidden');
        });

		analysisBtn.addEventListener('click', () => {
			displayAnalysis();
			analysisModal.classList.remove('hidden');
		});

		closeAnalysisBtn.addEventListener('click', () => {
			analysisModal.classList.add('hidden');
		});

		drillWeaknessesBtn.addEventListener('click', () => {
			startDrill();
		});

		endDrillBtn.addEventListener('click', () => {
			cleanupDrillState();
			const library = getLibrary();
			const currentBook = library.find(b => b.identifier === currentBookIdentifier);
			if (currentBook) {
				showTypingView(currentBook);
				loadChapter(currentChapterIndex, true);
			} else {
				showLibraryView(); // Fallback if the book isn't found
			}
		});

		drillMoreBtn.addEventListener('click', () => {
			// This will generate a new set of 50 words
			startDrill();
		});

    </script>

</body>
</html>
