<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Typing Tomes</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@700&family=Noto+Sans:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&family=Merriweather:wght@400;700&family=Source+Sans+Pro:wght@400;700&display=swap" rel="stylesheet">
	<style>
        /* Custom styles for the new UI */
        body {
            font-family: 'Noto Sans', sans-serif; /* UI Font */
        }
        /* More specific heading rules */
        h1, h3, .chapter-heading {
            font-family: 'Cormorant Garamond', serif; /* Decorative Font */
        }
        #book-title {
            font-family: 'Cormorant Garamond', serif;
            color: #818cf8; /* Tailwind's "indigo-400" color */
		}
        /* Font Options */
        .font-roboto-mono { font-family: 'Roboto Mono', monospace; }
        .font-lato { font-family: 'Lato', sans-serif; }
        .font-merriweather { font-family: 'Merriweather', serif; }
        .font-noto-sans { font-family: 'Noto Sans', sans-serif; }

        /* === FINAL CALIBRATED FONT SIZES === */
        /* V. Small */
        .font-merriweather.font-size-vs { font-size: 1.0rem; line-height: 1.8rem; }
        .font-lato.font-size-vs, .font-noto-sans.font-size-vs { font-size: 1.15rem; line-height: 2.0rem; }
        .font-roboto-mono.font-size-vs { font-size: 1.2rem; line-height: 2.1rem; }

        /* Small */
       .font-merriweather.font-size-sm { font-size: 1.25rem; line-height: 2.2rem; }
       .font-lato.font-size-sm, .font-noto-sans.font-size-sm { font-size: 1.4rem; line-height: 2.4rem; }
       .font-roboto-mono.font-size-sm { font-size: 1.5rem; line-height: 2.5rem; }

       /* Medium (New default) */
       .font-merriweather.font-size-md { font-size: 1.5rem; line-height: 2.5rem; }
       .font-lato.font-size-md, .font-noto-sans.font-size-md { font-size: 1.65rem; line-height: 2.7rem; }
       .font-roboto-mono.font-size-md { font-size: 1.8rem; line-height: 2.9rem; }

        /* Large */
        .font-merriweather.font-size-lg { font-size: 1.8rem; line-height: 2.9rem; }
        .font-lato.font-size-lg, .font-noto-sans.font-size-lg { font-size: 2.0rem; line-height: 3.1rem; }
        .font-roboto-mono.font-size-lg { font-size: 2.1rem; line-height: 3.2rem; }

        /* X-Large */
        .font-merriweather.font-size-xl { font-size: 2.2rem; line-height: 3.4rem; }
        .font-lato.font-size-xl, .font-noto-sans.font-size-xl { font-size: 2.4rem; line-height: 3.6rem; }
        .font-roboto-mono.font-size-xl { font-size: 2.5rem; line-height: 3.7rem; }
		/* Ensure UI headings use the correct font */
        h2 {
            font-family: 'Noto Sans', sans-serif;
        }
        /* Underline cursor effect */
        .cursor {
            border-bottom: 3px solid #f59e0b; /* amber-500 */
            animation: underline-pulse 1.5s ease-in-out infinite;
        }
        @keyframes underline-pulse {
            0%, 100% { border-color: #f59e0b; } /* amber-500 */
            50% { border-color: #fcd34d; } /* amber-300 */
        }
		
        /* Character styling */
        .char-span {
            transition: color 0.2s ease-in-out, background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;
            border-radius: 2px;
            padding-bottom: 2px; /* Add padding for the underline */
            border-bottom: 2px solid transparent;
        }
        .correct { color: #f3f4f6; } /* gray-100 */
        .incorrect-char {
            color: #f87171; /* red-400 text */
            border-bottom-color: #ef4444; /* red-500 underline */
        }
        .untyped { color: #9ca3af; } /* gray-400 */
        .skipped { color: #f3f4f6; } /* gray-100, for skipped paragraphs */
        /* Paragraph styling */
        .paragraph-block {
            margin-bottom: 2rem;
            overflow-wrap: break-word;
            hyphens: auto;
        }
        .chapter-heading {
            border-bottom: 2px solid #374151; /* gray-700 */
            padding-bottom: 0.5rem;
            margin-bottom: 2rem;
            margin-top: 3rem;
        }
        .ui-subheading {
            font-family: 'Noto Sans', sans-serif;
        }
		/* Modal styles */
        .modal-backdrop {
            background-color: rgba(0,0,0,0.7);
        }
        /* Chapter selection button styles */
        .choice-btn {
            transition: background-color 0.2s;
        }
        .choice-btn-active {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(99, 102, 241, 0.5);
        }
        /* Library book card style */
        .library-book-card {
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .library-book-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.4);
        }
        .library-book-card img {
            object-fit: cover;
            aspect-ratio: 2 / 3;
            background-color: #374151;
        }
        /* Drag-and-drop visual feedback */
        .drag-over {
            border-color: #f59e0b; /* amber-500 */
            background-color: rgba(245, 158, 11, 0.1);
        }
		/* Drill Completion Animation */
		.fanfare-char {
			display: inline-block;
			animation: color-shift 1.5s infinite;
		}
		@keyframes color-shift {
			0%   { color: #4ade80; } /* green-400 */
			25%  { color: #38bdf8; } /* sky-400 */
			50%  { color: #818cf8; } /* indigo-400 */
			75%  { color: #c084fc; } /* purple-400 */
			100% { color: #4ade80; } /* cycle back to green */
		}
    </style>
</head>
<body class="bg-gray-900 text-gray-200 flex flex-col items-center min-h-screen p-4 md:p-8">

    <div id="settings-modal" class="fixed inset-0 z-50 flex items-center justify-center modal-backdrop hidden">
        <div class="bg-gray-800 rounded-lg shadow-xl p-8 w-full max-w-lg">
            <h2 class="text-2xl font-bold text-white mb-6">Typing Settings</h2>
        
            <div class="mb-6">
                <label class="block text-lg font-medium text-gray-300 mb-3">Font Family</label>
                <div id="font-family-selector" class="grid grid-cols-2 sm:grid-cols-4 gap-4">
                    </div>
            </div>

            <div class="mb-8">
                <label class="block text-lg font-medium text-gray-300 mb-3">Font Size</label>
                <div id="font-size-selector" class="grid grid-cols-2 sm:grid-cols-4 gap-4">
                    </div>
            </div>
        
            <div class="mt-8 flex justify-end">
                <button id="close-settings-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-md">Done</button>
            </div>
        </div>
    </div>

	<div id="analysis-modal" class="fixed inset-0 z-50 flex items-center justify-center modal-backdrop hidden">
		<div class="bg-gray-800 rounded-lg shadow-xl p-4 sm:p-8 w-full max-w-2xl max-h-[90vh] flex flex-col">
			<h2 class="text-2xl font-bold text-white mb-4">Your Typing Analysis</h2>
			<p class="text-gray-400 mb-6">Here are your slowest letter combinations based on your typing history. Use the drill button to practice them.</p>

			<div class="flex-grow overflow-y-auto pr-4 grid grid-cols-1 md:grid-cols-2 gap-8 min-h-0">
				<div>
					<h3 class="text-lg font-semibold text-indigo-400 mb-3 ui-subheading">Slowest Bigrams (2-Letters)</h3>
					<div id="weak-bigrams-list" class="space-y-2">
						</div>
				</div>
				<div>
					<h3 class="text-lg font-semibold text-indigo-400 mb-3 ui-subheading">Slowest Trigrams (3-Letters)</h3>
					<div id="weak-trigrams-list" class="space-y-2">
						</div>
				</div>
			</div>

			<div class="mt-8 pt-4 border-t border-gray-700 flex justify-between items-center">
				<button id="close-analysis-btn" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-md">Close</button>
				<button id="drill-weaknesses-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md">Drill My Weaknesses</button>
			</div>
		</div>
	</div>

    <div id="profile-modal" class="fixed inset-0 z-50 flex items-center justify-center modal-backdrop hidden">
        <div class="bg-gray-800 rounded-lg shadow-xl p-8 w-full max-w-md">
            <h2 id="profile-modal-title" class="text-2xl font-bold text-white mb-4">Create Your Profile</h2>
            <p class="text-gray-400 mb-6">Enter a username to save your progress and track your results.</p>
            <div>
                <label for="username-input" class="block text-sm font-medium text-gray-300 mb-1">Username</label>
                <input type="text" id="username-input" class="w-full bg-gray-700 border border-gray-600 rounded-md p-2 focus:ring-2 focus:ring-indigo-500 focus:outline-none">
            </div>
            <div class="mt-6">
                <button id="save-profile-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-md">Save and Start</button>
            </div>
        </div>
    </div>

    <div id="profile-switcher-modal" class="fixed inset-0 z-50 flex items-center justify-center modal-backdrop hidden">
        <div class="bg-gray-800 rounded-lg shadow-xl p-8 w-full max-w-md">
            <h2 class="text-2xl font-bold text-white mb-6">Profile Manager</h2>
            <div id="profile-list-container" class="space-y-3 mb-6 max-h-64 overflow-y-auto">
                </div>
            <div class="pt-4 border-t border-gray-700">
                <button id="show-create-profile-btn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md">Add New Profile</button>
            </div>
        </div>
    </div>
    
    <div id="chapter-selection-modal" class="fixed inset-0 z-50 flex items-center justify-center modal-backdrop hidden">
        <div class="bg-gray-800 rounded-lg shadow-xl p-8 w-full max-w-2xl max-h-[90vh] flex flex-col">
            <h2 class="text-2xl font-bold text-white mb-2">Select Chapters to Type</h2>
            <p class="text-gray-400 mb-6">Choose which sections of the book you want to include in your typing practice.</p>
            <div id="chapter-list-container" class="overflow-y-auto flex-grow pr-4 min-h-0">
                </div>
            <div class="mt-6 pt-4 border-t border-gray-700 flex justify-end space-x-4">
                 <button id="cancel-add-book-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-md">Cancel</button>
                <button id="save-chapters-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-md">Save Book to Library</button>
            </div>
        </div>
    </div>


    <div class="w-full max-w-5xl mx-auto"> <header class="text-center mb-8">
            <h1 id="app-title-header" class="text-5xl md:text-6xl font-bold text-white">Typing Tomes</h1>
             <h1 id="book-title-header" class="text-5xl md:text-6xl font-bold hidden text-indigo-400"></h1>
            <p id="welcome-message" class="text-gray-400 mt-2 hidden">Welcome, <span id="username-display" class="font-bold text-white"></span>!
                <button id="change-user-btn" class="text-indigo-400 text-sm">(Change)</button>
            </p>
        </header>

        <div id="library-view" class="w-full">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-3xl font-bold text-white">My Library</h2>
                <button id="add-new-book-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-md">Add New Book</button>
            </div>
            <div id="library-list" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-6">
                </div>
        </div>


        <div id="file-loader" class="bg-gray-800 p-6 rounded-lg shadow-lg mb-8 hidden">
            <h2 class="text-xl font-semibold mb-4 text-white">Load a Book (.epub)</h2>
            <div id="drop-zone" class="flex flex-col items-center justify-center p-8 border-2 border-dashed border-gray-600 rounded-lg transition-colors">
                 <label for="local-file" class="block text-lg font-medium text-gray-300 mb-4 text-center">Drag & Drop EPUB file here<br>or click to select</label>
                 <input type="file" id="local-file" accept=".epub" class="block w-full max-w-xs text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100 cursor-pointer"/>
            </div>
            <div id="loading-status" class="text-center mt-4 text-amber-400"></div>
            <button id="back-to-library-btn" class="mt-4 w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-md">Back to Library</button>
        </div>

        <main id="typing-app" class="hidden flex-col">
            <div class="sticky top-0 bg-gray-900 py-4 z-10">
                <div class="grid grid-cols-2 lg:grid-cols-5 gap-4 text-center">
                    <div class="bg-gray-800 p-4 rounded-lg shadow">
                        <p class="text-sm text-gray-400">Live WPM</p>
                        <div id="live-wpm-display" class="text-3xl font-bold text-green-400">0</div>
                    </div>
                   <div class="bg-gray-800 p-4 rounded-lg shadow">
                        <p class="text-sm text-gray-400">Live Accuracy</p>
                        <div id="live-accuracy-display" class="text-3xl font-bold text-sky-400">100%</div>
                   </div>
                   <div class="bg-gray-800 p-4 rounded-lg shadow">
                        <p class="text-sm text-gray-400">Overall WPM</p>
                        <div id="overall-wpm-display" class="text-3xl font-bold text-gray-300">0.0</div>
                    </div>
                    <div class="bg-gray-800 p-4 rounded-lg shadow">
                        <p class="text-sm text-gray-400">Overall Accuracy</p>
                        <div id="overall-accuracy-display" class="text-3xl font-bold text-blue-400">100%</div>
                    </div>
                    <div class="bg-gray-800 p-4 rounded-lg shadow col-span-2 lg:col-span-1">
                        <p class="text-sm text-gray-400">Paragraphs Done</p>
                        <div id="paragraph-count" class="text-3xl font-bold text-purple-400">0 / 0</div>
                    </div>
                </div>
            </div>

            <div class="mt-6">
                 <div id="chapter-selector-container" class="mb-4 hidden">
                    <label for="chapter-selector" class="block text-sm font-medium text-gray-300 mb-1">Jump to Chapter</label>
                    <select id="chapter-selector" class="w-full bg-gray-700 border border-gray-600 rounded-md p-2 focus:ring-2 focus:ring-indigo-500 focus:outline-none"></select>
                </div>

                <div id="chapter-stats" class="text-center text-gray-400 mb-4"></div>
                <div class="bg-gray-800 p-6 rounded-lg shadow-lg relative">
                     <div id="book-content" class="select-none overflow-y-auto focus:outline-none" style="max-height: 70vh;">
                         </div>
                     <div class="text-right text-gray-400 text-sm mt-4">
                         <span>Press <kbd class="font-sans bg-gray-600 text-gray-200 rounded px-2 py-1">Tab</kbd> to restart paragraph.</span>
                         <span>Press <kbd class="font-sans bg-gray-600 text-gray-200 rounded px-2 py-1">Enter</kbd> to finish.<span> Press <kbd class="font-sans bg-gray-600 text-gray-200 rounded px-2 py-1">Shift+Enter</kbd> to skip.</span><span> Press <kbd class="font-sans bg-gray-600 text-gray-200 rounded px-2 py-1">Shift+Tab</kbd> to redo previous.</span></span>
                     </div>
                </div>

                <div class="bg-gray-800 p-6 rounded-lg shadow-lg mt-8">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-xl font-semibold text-white ui-subheading">Performance History</h3>
						    <button id="chart-toggle-btn" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-md text-sm">Show Entire Book</button>
                    </div>
                    <canvas id="history-chart"></canvas>
                </div>
            </div>
        
            <div class="mt-8 flex justify-between items-center">
                <button id="exit-to-library-btn" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-md">‚Üê Back to Library</button>
				<button id="analysis-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md">Analysis and Drills</button>
                <button id="settings-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-md">Settings</button>
            </div>		
		
		</main>
		
		<main id="drill-mode" class="hidden flex-col">
            <div class="py-4 z-10">
                <h2 class="text-3xl font-bold text-center text-green-400 mb-4">Practice Drill</h2>
                <div class="grid grid-cols-3 gap-4 text-center">
                    <div class="bg-gray-800 p-4 rounded-lg shadow">
                        <p class="text-sm text-gray-400">Drill WPM</p>
                        <div id="drill-wpm-display" class="text-3xl font-bold text-green-400">0</div>
                    </div>
                    <div class="bg-gray-800 p-4 rounded-lg shadow">
                        <p class="text-sm text-gray-400">Drill Accuracy</p>
                        <div id="drill-accuracy-display" class="text-3xl font-bold text-sky-400">100%</div>
                    </div>
                    <div class="bg-gray-800 p-4 rounded-lg shadow">
                        <p class="text-sm text-gray-400">Words Typed</p>
                        <div id="drill-word-count" class="text-3xl font-bold text-purple-400">0 / 50</div>
                    </div>
                </div>
            </div>
    
            <div class="mt-6 bg-gray-800 p-6 rounded-lg shadow-lg relative">
                <div id="drill-content" class="select-none overflow-y-auto text-3xl leading-loose focus:outline-none" style="max-height: 50vh;" tabindex="-1">
                </div>
            </div>
    
            <div class="mt-8 flex justify-between items-center">
                <button id="end-drill-btn" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-md">End Drill</button>
                <button id="drill-more-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md">Drill More Words</button>
            </div>
        </main>
		
    </div>

    <script>
        // DOM Elements
		const drillModeSection = document.getElementById('drill-mode');
		const drillContentEl = document.getElementById('drill-content');
		const drillWpmDisplay = document.getElementById('drill-wpm-display');
		const drillAccuracyDisplay = document.getElementById('drill-accuracy-display');
		const drillWordCount = document.getElementById('drill-word-count');
		const endDrillBtn = document.getElementById('end-drill-btn');
		const drillMoreBtn = document.getElementById('drill-more-btn');
		const analysisModal = document.getElementById('analysis-modal');
		const analysisBtn = document.getElementById('analysis-btn');
		const closeAnalysisBtn = document.getElementById('close-analysis-btn');
		const drillWeaknessesBtn = document.getElementById('drill-weaknesses-btn');
		const weakBigramsList = document.getElementById('weak-bigrams-list');
		const weakTrigramsList = document.getElementById('weak-trigrams-list');
        const libraryView = document.getElementById('library-view');
        const libraryList = document.getElementById('library-list');
        const addNewBookBtn = document.getElementById('add-new-book-btn');
        const fileLoaderSection = document.getElementById('file-loader');
        const backToLibraryBtn = document.getElementById('back-to-library-btn');
        const exitToLibraryBtn = document.getElementById('exit-to-library-btn');
        const typingAppSection = document.getElementById('typing-app');
        const localFileInput = document.getElementById('local-file');
        const loadingStatus = document.getElementById('loading-status');
        const dropZone = document.getElementById('drop-zone');
        const settingsModal = document.getElementById('settings-modal');
        const settingsBtn = document.getElementById('settings-btn');
        const closeSettingsBtn = document.getElementById('close-settings-btn');
        const fontFamilySelector = document.getElementById('font-family-selector');
        const fontSizeSelector = document.getElementById('font-size-selector');

        // --- MASTER LISTS FOR ADAPTIVE TRAINING ---

        // Top 2000 most common English words (2-10 letters long)
        const MASTER_WORDS_2K = ["the", "of", "to", "and", "in", "is", "it", "you", "that", "he", "was", "for", "on", "are", "with", "as", "his", "they", "be", "at", "one", "have", "this", "from", "or", "had", "by", "not", "word", "but", "what", "some", "we", "can", "out", "other", "were", "all", "there", "when", "up", "use", "your", "how", "said", "an", "each", "she", "which", "do", "their", "time", "if", "will", "way", "about", "many", "then", "them", "write", "would", "like", "so", "these", "her", "long", "make", "thing", "see", "him", "two", "has", "look", "more", "day", "could", "go", "come", "did", "number", "sound", "no", "most", "people", "my", "over", "know", "water", "than", "call", "first", "who", "may", "down", "side", "been", "now", "find", "any", "new", "work", "part", "take", "get", "place", "made", "live", "where", "after", "back", "little", "only", "round", "man", "year", "came", "show", "every", "good", "me", "give", "our", "under", "name", "very", "through", "just", "form", "sentence", "great", "think", "say", "help", "low", "line", "differ", "turn", "cause", "much", "mean", "before", "move", "right", "boy", "old", "too", "same", "tell", "does", "set", "three", "want", "air", "well", "also", "play", "small", "end", "put", "home", "read", "hand", "port", "large", "spell", "add", "even", "land", "here", "must", "big", "high", "such", "follow", "act", "why", "ask", "men", "change", "went", "light", "kind", "off", "need", "house", "picture", "try", "us", "again", "animal", "point", "mother", "world", "near", "build", "self", "earth", "father", "head", "stand", "own", "page", "should", "country", "found", "answer", "school", "grow", "study", "still", "learn", "plant", "cover", "food", "sun", "four", "between", "state", "keep", "eye", "never", "last", "let", "thought", "city", "tree", "cross", "farm", "hard", "start", "might", "story", "saw", "far", "sea", "draw", "left", "late", "run", "while", "press", "close", "night", "real", "life", "few", "north", "open", "seem", "together", "next", "white", "children", "begin", "got", "walk", "example", "ease", "paper", "group", "always", "music", "those", "both", "mark", "often", "letter", "until", "mile", "river", "car", "feet", "care", "second", "book", "carry", "took", "science", "eat", "room", "friend", "began", "idea", "fish", "mountain", "stop", "once", "base", "hear", "horse", "cut", "sure", "watch", "color", "face", "wood", "main", "enough", "plain", "girl", "usual", "young", "ready", "above", "ever", "red", "list", "though", "feel", "talk", "bird", "soon", "body", "dog", "family", "direct", "pose", "leave", "song", "measure", "door", "product", "black", "short", "numeral", "class", "wind", "question", "happen", "complete", "ship", "area", "half", "rock", "order", "fire", "south", "problem", "piece", "told", "knew", "pass", "since", "top", "whole", "king", "space", "heard", "best", "hour", "better", "true", "during", "hundred", "five", "remember", "step", "early", "hold", "west", "ground", "interest", "reach", "fast", "verb", "sing", "listen", "six", "table", "travel", "less", "morning", "ten", "simple", "several", "vowel", "toward", "war", "lay", "against", "pattern", "slow", "center", "love", "person", "money", "serve", "appear", "road", "map", "rain", "rule", "govern", "pull", "cold", "notice", "voice", "unit", "power", "town", "fine", "certain", "fly", "fall", "lead", "cry", "dark", "machine", "note", "wait", "plan", "figure", "star", "box", "noun", "field", "rest", "correct", "able", "pound", "done", "beauty", "drive", "stood", "contain", "front", "teach", "week", "final", "gave", "green", "oh", "quick", "develop", "ocean", "warm", "free", "minute", "strong", "special", "mind", "behind", "clear", "tail", "produce", "fact", "street", "inch", "multiply", "nothing", "course", "stay", "wheel", "full", "force", "blue", "object", "decide", "surface", "deep", "moon", "island", "foot", "system", "busy", "test", "record", "boat", "common", "gold", "possible", "plane", "stead", "dry", "wonder", "laugh", "thousand", "ago", "ran", "check", "game", "shape", "equate", "hot", "miss", "brought", "heat", "snow", "tire", "bring", "yes", "distant", "fill", "east", "paint", "language", "among", "grand", "ball", "yet", "wave", "drop", "heart", "am", "present", "heavy", "dance", "engine", "position", "arm", "wide", "sail", "material", "size", "vary", "settle", "speak", "weight", "general", "ice", "matter", "circle", "pair", "include", "divide", "syllable", "felt", "perhaps", "pick", "sudden", "count", "square", "reason", "length", "represent", "art", "subject", "region", "energy", "hunt", "probable", "bed", "brother", "egg", "ride", "cell", "believe", "fraction", "forest", "sit", "race", "window", "store", "summer", "train", "sleep", "prove", "lone", "leg", "exercise", "wall", "catch", "mount", "wish", "sky", "board", "joy", "winter", "sat", "written", "wild", "instrument", "kept", "glass", "grass", "cow", "job", "edge", "sign", "visit", "past", "soft", "fun", "bright", "gas", "weather", "month", "million", "bear", "finish", "happy", "hope", "flower", "clothes", "strange", "gone", "jump", "baby", "eight", "village", "meet", "root", "buy", "raise", "solve", "metal", "whether", "push", "seven", "paragraph", "third", "shall", "held", "hair", "describe", "cook", "floor", "either", "result", "burn", "hill", "safe", "cat", "century", "consider", "type", "law", "bit", "coast", "copy", "phrase", "silent", "tall", "sand", "soil", "roll", "temperature", "finger", "industry", "value", "fight", "lie", "beat", "excite", "natural", "view", "sense", "ear", "else", "quite", "broke", "case", "middle", "kill", "son", "lake", "moment", "scale", "loud", "spring", "observe", "child", "straight", "consonant", "nation", "dictionary", "milk", "speed", "method", "organ", "pay", "age", "section", "dress", "cloud", "surprise", "quiet", "stone", "tiny", "climb", "cool", "design", "poor", "lot", "experiment", "bottom", "key", "iron", "single", "stick", "flat", "twenty", "skin", "smile", "crease", "hole", "trade", "melody", "trip", "office", "receive", "row", "mouth", "exact", "symbol", "die", "least", "trouble", "shout", "except", "wrote", "seed", "tone", "join", "suggest", "clean", "break", "lady", "yard", "rise", "bad", "blow", "oil", "blood", "touch", "grew", "cent", "mix", "team", "wire", "cost", "lost", "brown", "wear", "garden", "equal", "sent", "choose", "fell", "fit", "flow", "fair", "bank", "collect", "save", "control", "decimal", "gentle", "woman", "captain", "practice", "separate", "difficult", "doctor", "please", "protect", "noon", "whose", "locate", "ring", "character", "insect", "caught", "period", "indicate", "radio", "spoke", "atom", "human", "history", "effect", "electric", "expect", "crop", "modern", "element", "hit", "student", "corner", "party", "supply", "bone", "rail", "imagine", "provide", "agree", "thus", "capital", "chair", "danger", "fruit", "rich", "thick", "soldier", "process", "operate", "guess", "necessary", "sharp", "wing", "create", "neighbor", "wash", "bat", "rather", "crowd", "corn", "compare", "poem", "string", "bell", "depend", "meat", "rub", "tube", "famous", "dollar", "stream", "fear", "sight", "thin", "triangle", "planet", "hurry", "chief", "colony", "clock", "mine", "tie", "enter", "major", "fresh", "search", "send", "yellow", "gun", "allow", "print", "dead", "spot", "desert", "suit", "current", "lift", "rose", "continue", "block", "chart", "hat", "sell", "success", "company", "subtract", "event", "particular", "deal", "swim", "term", "opposite", "wife", "shoe", "shoulder", "spread", "arrange", "camp", "invent", "cotton", "born", "determine", "quart", "nine", "truck", "noise", "level", "chance", "gather", "shop", "stretch", "throw", "shine", "property", "column", "molecule", "select", "wrong", "gray", "repeat", "require", "broad", "prepare", "salt", "nose", "plural", "anger", "claim", "continent", "oxygen", "sugar", "death", "pretty", "skill", "women", "season", "solution", "magnet", "silver", "thank", "branch", "match", "suffix", "especially", "fig", "afraid", "huge", "sister", "steel", "discuss", "forward", "similar", "guide", "experience", "score", "apple", "bought", "led", "pitch", "coat", "mass", "card", "band", "rope", "slip", "win", "dream", "evening", "condition", "feed", "tool", "total", "basic", "smell", "valley", "nor", "double", "seat", "arrive", "master", "track", "parent", "shore", "division", "sheet", "substance", "favor", "connect", "post", "spend", "chord", "fat", "glad", "original", "share", "station", "dad", "bread", "charge", "proper", "bar", "offer", "segment", "duck", "instant", "market", "degree", "populate", "chick", "dear", "enemy", "reply", "drink", "occur", "support", "speech", "nature", "range", "steam", "motion", "path", "liquid", "log", "meant", "quotient", "teeth", "shell", "neck", "program", "public", "universe", "site", "contact", "business", "web", "online", "services", "click", "service", "price", "date", "into", "email", "health", "used", "data", "policy", "available", "copyright", "message", "software", "video", "info", "links", "review", "privacy", "items", "user", "research", "university", "mail", "management", "united", "hotel", "item", "comments", "report", "member", "details", "because", "local", "using", "education", "national", "posted", "internet", "address", "community", "within", "phone", "shipping", "reserved", "forum", "based", "code", "website", "index", "being", "file", "link", "today", "technology", "project", "version", "sports", "related", "security", "county", "photo", "network", "computer", "following", "download", "without", "per", "access", "think", "resources", "posts", "media", "law", "control", "pictures", "personal", "including", "directory", "board", "location", "rating", "government", "during", "return", "students", "shopping", "account", "sites", "digital", "profile", "previous", "events", "image", "title", "another", "shall", "class", "customer", "December", "compare", "movies", "include", "college", "article", "jobs", "author", "press", "learn", "sale", "around", "Canada", "teen", "stock", "training", "credit", "point", "science", "advanced", "sales", "look", "English", "estate", "select", "windows", "photos", "gay", "thread", "category", "gallery", "table", "register", "however", "June", "October", "November", "library", "really", "action", "series", "model", "features", "industry", "human", "provided", "yes", "required", "hot", "cost", "movie", "forums", "march", "September", "better", "questions", "July", "going", "medical", "server", "study", "cart", "staff", "articles", "feedback", "looking", "April", "never", "complete", "street", "topic", "comment", "things", "working", "against", "standard", "tax", "below", "mobile", "less", "got", "blog", "party", "payment", "login", "student", "let", "offers", "legal", "above", "recent", "park", "side", "act", "red", "give", "memory", "social", "August", "quote", "sell", "options", "rates", "create", "key", "body", "young", "America", "important", "field", "few", "east", "paper", "single", "age", "club", "girls", "password", "latest", "something", "gift", "question", "night", "hard", "Texas", "pay", "four", "poker", "status", "browse", "issue", "range", "building", "seller", "court", "February", "always", "result", "audio", "light", "write", "offer", "blue", "easy", "given", "event", "release", "analysis", "request", "fax", "China", "making", "needs", "possible", "might", "yet", "month", "major", "star", "areas", "future", "space", "hand", "sun", "cards", "London", "meeting", "become", "interest", "child", "keep", "enter", "share", "similar", "garden", "million", "added", "learning", "energy", "run", "delivery", "net", "popular", "term", "film", "put", "journal", "try", "welcome", "central", "images", "notice", "god", "head", "radio", "until", "cell", "color", "self", "council", "away", "includes", "track", "once", "archive", "further", "updated", "able", "having", "provides", "fun", "already", "green", "studies", "close", "common", "drive", "specific", "several", "gold", "living", "called", "arts", "lot", "ask", "display", "limited", "powered", "means", "director", "daily", "beach", "past", "natural", "whether", "due", "five", "upon", "period", "planning", "says", "official", "weather", "mar", "land", "average", "done", "technical", "window", "France", "pro", "region", "island", "record", "direct", "update", "parts", "ever", "early", "miles", "sound", "resource", "present", "either", "ago", "document", "works", "material", "bill", "written", "talk", "federal", "rules", "final", "adult", "tickets", "thing", "via", "cheap", "kids", "finance", "true", "minutes", "else", "mark", "third", "rock", "gifts", "Europe", "reading", "topics", "bad", "tips", "plus", "auto", "cover", "usually", "edit", "together", "videos", "percent", "fast", "function", "fact", "unit", "getting", "global", "tech", "meet", "far", "economic", "player", "lyrics", "often", "subscribe", "submit", "Germany", "amount", "watch", "included", "feel", "though", "bank", "risk", "thanks", "deals", "various", "words", "weight", "town", "heart", "received", "choose", "camera", "girl", "clear", "golf", "receive", "domain", "methods", "chapter", "makes", "loan", "wide", "beauty", "manager", "India", "position", "taken", "sort", "known", "half", "cases", "step", "simple", "quick", "none", "license", "Friday", "lake", "whole", "annual", "later", "basic", "shows", "church", "method", "purchase", "active", "response", "practice", "hardware", "figure", "fire", "holiday", "chat", "enough", "along", "among", "death", "writing", "speed", "loss", "face", "brand", "discount", "higher", "created", "remember", "oil", "bit", "yellow", "increase", "kingdom", "base", "near", "thought", "stuff", "French", "storage", "Japan", "doing", "shoes", "entry", "stay", "nature", "orders", "Africa", "summary", "turn", "mean", "growth", "notes", "agency", "king", "Monday", "copy", "although", "drug", "pics", "western", "income", "force", "cash", "overall", "bay", "river", "ad", "package", "seen", "engine", "port", "album", "stop", "started", "bar", "views", "plans", "double", "dog", "build", "screen", "exchange", "types", "soon", "lines", "continue", "across", "benefits", "needed", "season", "apply", "someone", "held", "anything", "printer", "effect", "asked", "mind", "Sunday", "lost", "tour", "menu", "volume", "cross", "anyone", "hope", "silver", "wish", "inside", "mature", "role", "rather", "weeks", "addition", "came", "supply", "nothing", "certain", "running", "lower", "union", "jewelry", "fine", "names", "homepage", "hour", "gas", "skills", "six", "bush", "advice", "career", "military", "rental", "leave", "British", "teens", "huge", "sat", "woman", "zip", "bid", "kind", "middle", "move", "cable", "taking", "values", "coming", "Tuesday", "object", "machine", "logo", "length", "actually", "nice", "score", "client", "capital", "follow", "sample", "sent", "shown", "saturday", "England", "culture", "band", "flash", "lead", "choice", "went", "starting", "Thursday", "consumer", "hi", "airport", "foreign", "artist", "outside", "levels", "channel", "letter", "mode", "phones", "ideas", "Wednesday", "fund", "summer", "allow", "degree", "contract", "button", "wed", "homes", "super", "male", "matter", "custom", "almost", "took", "located", "multiple", "Asian", "editor", "inn", "cause", "song", "focus", "late", "fall", "idea", "rooms", "female", "win", "primary", "cancer", "reason", "tool", "browser", "spring", "answer", "voice", "friendly", "bed", "comes", "police", "everyone", "brown", "physical", "hill", "maps", "medicine", "deal", "hold", "Chicago", "forms", "glass", "happy", "smith", "wanted", "thank", "safe", "unique", "survey", "prior", "sport", "ready", "feed", "animal", "Mexico", "regular", "secure", "station", "round", "favorite", "option", "master", "valley", "sea", "built", "blood", "cut", "improve", "larger", "earth", "parents", "impact", "ship", "owners", "disease", "paid", "Italy", "perfect", "hair", "kit", "classic", "basis", "command", "cities", "express", "award", "distance", "tree", "wall", "involved", "extra", "budget", "rated", "guides", "success", "maximum", "existing", "quite", "boy", "wine", "horse", "vote", "forward", "flowers", "stars", "owner", "retail", "useful", "directly", "ways", "son", "providing", "rule", "housing", "takes", "bring", "catalog", "trying", "mother", "told", "traffic", "joined", "input", "feet", "agent", "valid", "bin", "modern", "senior", "Ireland", "teaching", "door", "grand", "testing", "trial", "charge", "units", "instead", "cool", "normal", "wrote", "ships", "entire", "metal", "positive", "fitness", "Chinese", "opinion", "Asia", "football", "abstract", "uses", "output", "funds", "greater", "likely", "develop", "guest", "seems", "pass", "trust", "van", "session", "multi", "fees", "century", "skin", "ads", "expected", "ring", "grade", "dating", "Pacific", "mountain", "pop", "filter", "mailing", "vehicle", "longer", "consider", "northern", "behind", "panel", "floor", "German", "buying", "match", "proposed", "default", "require", "Iraq", "boys", "outdoor", "deep", "morning", "allows", "rest", "protein", "plant", "reported", "hit", "pool", "politics", "partner", "authors", "boards", "faculty", "parties", "fish", "eye", "string", "sense", "pack", "released", "stage", "internal", "goods", "born", "unless", "detailed", "Japanese", "race", "approved", "target", "except", "maybe", "moving", "brands", "places", "pretty", "Spain", "southern", "winter", "battery", "youth", "pressure", "Boston", "debt", "medium", "core", "break", "sets", "dance", "wood", "itself", "defined", "papers", "playing", "awards", "fee", "studio", "reader", "virtual", "device", "answers", "rent", "remote", "dark", "external", "apple", "enjoy", "remove", "aid", "surface", "minimum", "visual", "host", "variety", "manual", "block", "agents", "repair", "fair", "civil", "steel", "songs", "fixed", "wrong", "beginning", "hands", "finally", "updates", "desktop", "Paris", "Ohio", "gets", "sector", "fully", "father", "electric", "saw", "quotes", "officer", "driver", "dead", "respect", "unknown", "trip", "worth", "poor", "teacher", "eyes", "workers", "farm", "peace", "campus", "showing", "creative", "coast", "benefit", "progress", "funding", "lord", "grant", "agree", "fiction", "hear", "sometimes", "goes", "families", "led", "museum", "fan", "transport", "wife", "ten", "hits", "zone", "complex", "cat", "die", "flat", "flow", "parent", "Spanish", "setting", "scale", "stand", "economy", "highest", "helpful", "monthly", "critical", "frame", "musical", "path", "employee", "chief", "gives", "bottom", "detail", "laws", "changed", "pet", "heard", "begin", "Colorado", "royal", "clean", "switch", "Russian", "largest", "African", "guy", "titles", "relevant", "justice", "connect", "bible", "cup", "basket", "applied", "weekly", "suite", "square", "advance", "skip", "diet", "army", "auction", "gear", "lee", "allowed", "correct", "nation", "selling", "lots", "piece", "sheet", "firm", "seven", "older", "jump", "cells", "module", "resort", "random", "pricing", "looks", "fashion", "visitors", "monitor", "trading", "forest", "calls", "whose", "couple", "giving", "chance", "vision", "ball", "ending", "clients", "actions", "listen", "discuss", "accept", "goal", "sold", "wind", "clinical", "lowest", "highly", "appear", "lives", "currency", "leather", "palm", "patient", "actual", "stone", "commerce", "perhaps", "persons", "fit", "tests", "village", "amateur", "met", "pain", "factors", "coffee", "buyer", "cultural", "easily", "oral", "ford", "poster", "edge", "root", "closed", "holidays", "ice", "pink", "balance", "shot", "initial", "label", "thinking", "league", "waste", "minute", "bus", "optional", "cold", "chair", "fishing", "effort", "phase", "fields", "bag", "fantasy", "letters", "motor", "context", "install", "shirt", "foot", "mass", "crime", "count", "quickly", "dollars", "religion", "claim", "driving", "surgery", "patch", "heat", "wild", "generation", "Kansas", "miss", "chemical", "doctor", "task", "reduce", "brought", "himself", "nor", "enable", "exercise", "bug", "santa", "leader", "diamond", "Israel", "soft", "servers", "alone", "seconds", "Arizona", "keyword", "flight", "Congress", "fuel", "username", "walk", "produced", "Italian", "wait", "pocket", "saint", "rose", "freedom", "creating", "drugs", "joint", "premium", "fresh", "attorney", "upgrade", "factor", "growing", "stream", "pick", "hearing", "eastern", "therapy", "entries", "dates", "signed", "upper", "serious", "prime", "limit", "began", "steps", "errors", "shops", "bondage", "efforts", "informed", "creek", "worked", "quantity", "urban", "sorted", "myself", "tours", "platform", "load", "affiliate", "labor", "admin", "nursing", "defense", "heavy", "covered", "recovery", "guys", "merchant", "expert", "protect", "drop", "solid", "became", "orange", "prevent", "theme", "rich", "campaign", "marine", "guitar", "finding", "saying", "spirit", "challenge", "acceptance", "strategies", "affairs", "intended", "hire", "election", "magic", "smart", "talking", "gave", "ones", "Latin", "multimedia", "avoid", "certified", "manage", "rank", "computing", "birth", "virus", "abuse", "quarter", "procedure", "leadership", "define", "racing", "religious", "breakfast", "faith", "chain", "developer", "identify", "avenue", "missing", "died", "domestic", "moved", "comparison", "mental", "viewed", "extended", "sequence", "attack", "sorry", "opening", "damage", "reserve", "recipes", "gamma", "plastic", "placed", "truth", "counter", "failure", "weekend", "bridge", "native", "movement", "printing", "baseball", "owned", "approval", "draft", "played", "adventure", "matching", "offering", "profit", "assistant", "variable", "parking", "headlines"];

        // Top 200 most common English bigrams (letter pairs)
        const MASTER_BIGRAMS_200 = ["th", "he", "in", "er", "an", "re", "on", "at", "en", "nd", "ti", "es", "or", "te", "of", "ed", "is", "it", "al", "ar", "st", "to", "nt", "ng", "se", "ha", "as", "ou", "io", "le", "ve", "co", "me", "de", "hi", "ri", "ro", "ic", "ne", "ea", "ra", "ce", "li", "ch", "ll", "be", "ma", "si", "om", "ur", "ca", "el", "ta", "la", "ns", "di", "fo", "ho", "pe", "ec", "pr", "no", "ct", "us", "ac", "ot", "il", "tr", "ly", "nc", "et", "ut", "ss", "so", "rs", "un", "lo", "wa", "ge", "ie", "wh", "ee", "wi", "em", "ad", "ol", "rt", "po", "we", "na", "ul", "ni", "ts", "mo", "ow", "pa", "im", "mi", "ai", "sh", "ir", "su", "id", "os", "iv", "ia", "am", "fi", "ci", "vi", "pl", "ig", "tu", "ev", "ld", "ry", "mp", "fe", "bl", "ab", "gh", "ty", "op", "wo", "sa", "ay", "ex", "ke", "fr", "oo", "av", "ag", "if", "ap", "gr", "od", "bo", "sp", "rd", "do", "uc", "bu", "ei", "ov", "by", "rm", "ep", "tt", "oc", "fa", "ef", "cu", "rn", "sc", "gi", "da", "yo", "cr", "cl", "du", "ga", "qu", "ue", "ff", "ba", "ey", "ls", "va", "um", "pp", "ua", "up", "lu", "go", "ht", "ru", "ug", "ds", "lt", "pi", "rc", "rr", "eg", "au", "ck", "ew", "mu", "br", "bi", "pt", "ak", "pu", "ui", "rg", "ib", "tl", "ny", "ki", "rk", "ys", "ob", "mm", "fu", "ph", "og", "ms", "ye", "ud", "mb", "ip", "ub", "oi", "rl", "gu", "dr", "hr", "cc", "tw", "ft", "wn", "nu", "af", "hu", "nn", "eo", "vo", "rv", "nf", "xp", "gn", "sm", "fl", "iz", "ok", "nl", "my", "gl", "aw", "ju", "oa", "eq", "sy", "sl", "ps", "jo", "lf", "nv", "je", "nk", "kn"];

        // Top 200 most common English trigrams (letter triplets)
        const MASTER_TRIGRAMS_200 = ["the", "and", "ing", "ion", "tio", "ent", "ati", "for", "her", "ter", "hat", "tha", "ere", "ate", "his", "con", "res", "ver", "all", "ons", "nce", "men", "ith", "ted", "ers", "pro", "thi", "wit", "are", "ess", "not", "ive", "was", "ect", "rea", "com", "eve", "per", "int", "est", "sta", "cti", "ica", "ist", "ear", "ain", "one", "our", "iti", "rat", "nte", "tin", "ine", "der", "ome", "man", "pre", "rom", "tra", "whi", "ave", "str", "act", "ill", "ure", "ide", "ove", "cal", "ble", "out", "sti", "tic", "oun", "enc", "ore", "ant", "ity", "fro", "art", "tur", "par", "red", "oth", "eri", "hic", "ies", "ste", "ght", "ich", "igh", "und", "you", "ort", "era", "wer", "nti", "oul", "nde", "ind", "tho", "hou", "nal", "but", "hav", "uld", "use", "han", "hin", "een", "ces", "cou", "lat", "tor", "ese", "age", "ame", "rin", "anc", "ten", "hen", "min", "eas", "can", "lit", "cha", "ous", "eat", "end", "ssi", "ial", "les", "ren", "tiv", "nts", "whe", "tat", "abl", "dis", "ran", "wor", "rou", "lin", "had", "sed", "ont", "ple", "ugh", "inc", "sio", "din", "ral", "ust", "tan", "nat", "ins", "ass", "pla", "ven", "ell", "she", "ose", "ite", "lly", "rec", "lan", "ard", "hey", "rie", "pos", "eme", "mor", "den", "oug", "tte", "ned", "rit", "ime", "sin", "ast", "any", "orm", "ndi", "ona", "spe", "ene", "hei", "ric", "ice", "ord", "omp", "nes", "sen", "tim", "tri", "ern", "tes", "por", "app", "lar", "ntr", "eir", "sho", "son", "cat", "lle", "ner", "hes", "who", "mat", "ase", "kin", "ost", "ber", "its", "nin", "lea", "ina", "mpl", "sto", "ari", "pri", "own", "ali", "ree", "ish", "des", "ead", "nst", "sit", "ses", "ans", "has", "gre", "ong", "als", "fic", "ual", "ien", "gen", "ser", "unt", "eco", "nta", "ace", "chi", "fer", "tal", "low", "ach", "ire"];

        // Add these new constants for the settings options
        const FONT_OPTIONS = {
            'roboto-mono': 'Roboto Mono',
            'lato': 'Lato',
            'merriweather': 'Merriweather',
            'noto-sans': 'Noto Sans'
        };
        const FONT_SIZES = {
            'vs': 'V. Small',
            'sm': 'Small',
            'md': 'Medium',
            'lg': 'Large',
            'xl': 'X-Large'
        };
		
        const appTitleHeader = document.getElementById('app-title-header');
        const bookTitleHeader = document.getElementById('book-title-header');
		const bookContentEl = document.getElementById('book-content');
		let currentContentEl = bookContentEl; // This will track the active typing area
        const liveWpmDisplay = document.getElementById('live-wpm-display');
        const liveAccuracyDisplay = document.getElementById('live-accuracy-display');
        const overallWpmDisplay = document.getElementById('overall-wpm-display');
        const overallAccuracyDisplay = document.getElementById('overall-accuracy-display');
        const paragraphCountDisplay = document.getElementById('paragraph-count');
        const chapterStatsDisplay = document.getElementById('chapter-stats');
        const chartToggleButton = document.getElementById('chart-toggle-btn');
        const chapterSelectorContainer = document.getElementById('chapter-selector-container');
        const chapterSelector = document.getElementById('chapter-selector');
        
        // Profile Modal Elements
        const profileModal = document.getElementById('profile-modal');
        const profileModalTitle = document.getElementById('profile-modal-title');
        const usernameInput = document.getElementById('username-input');
        const saveProfileBtn = document.getElementById('save-profile-btn');
        const usernameDisplay = document.getElementById('username-display');
        const welcomeMessage = document.getElementById('welcome-message');
        const changeUserBtn = document.getElementById('change-user-btn');
        const deleteUserBtn = document.getElementById('delete-user-btn');

        // Profile Switcher Elements (added)
        const profileSwitcherModal = document.getElementById('profile-switcher-modal');
        const profileListContainer = document.getElementById('profile-list-container');
        const showCreateProfileBtn = document.getElementById('show-create-profile-btn');
        const cancelCreateProfileBtn = document.getElementById('cancel-create-profile-btn'); // may be null

        // Chapter Selection Modal Elements
        const chapterSelectionModal = document.getElementById('chapter-selection-modal');
        const chapterListContainer = document.getElementById('chapter-list-container');
        const saveChaptersBtn = document.getElementById('save-chapters-btn');
        const cancelAddBookBtn = document.getElementById('cancel-add-book-btn');

        // App State
        const CHARS_PER_WORD = 5; // Use industry standard of 5
        let currentUsername = '';
		let currentParagraphAnalysis = {};
        let currentBookIdentifier = ''; // Use a unique ID for the book
        let fullBookText = '';
        let chapterMarkers = [];
        let currentChapterIndex = -1;
        let currentChapterWordCount = 0; 
		let isDrillActive = false; // To track when we are in drill mode
		let drillTargetLength = 0;
		let drillTotalWords = 0;
        
        let currentChapterParagraphs = [];
        let currentParagraphIndexInChapter = -1;
        
        let currentUserInput = '';
        let isTestActive = false;
        let isBookLoading = false;
        
        // Temporary state for book being added
        let tempBookData = {};
        
        // Live WPM state
        let paragraphKeyPressLog = [];
        let liveAccuracyLog = [];

        // Stats
        let history = { wpm: [], accuracy: [], labels: [], overallWpmHistory: [], cumulativeWords: [], chapterIndices: [], paragraphWordCounts: [], cumulativeWordsInChapter: [], rawTimes: [], rawCorrectChars: [], rawTypedChars: [] };
        let historyChart;
        let isShowingAllHistory = false;
        let overallStats = {
            totalCorrectChars: 0,
            totalTypedChars: 0,
            totalTime: 0,
            cumulativeWordCount: 0,
        };

        const getSettingsKey = () => `typingSettings_${currentUsername}`;

        const saveSettings = (settings) => {
            if (!currentUsername) return;
            localStorage.setItem(getSettingsKey(), JSON.stringify(settings));
        };

        const loadSettings = () => {
            const saved = localStorage.getItem(getSettingsKey());
            const defaults = { fontFamily: 'roboto-mono', fontSize: 'md' };
            if (saved) {
                return { ...defaults, ...JSON.parse(saved) };
            }
            return defaults;
        };

        const applySettings = () => {
            const settings = loadSettings();
            const fontClass = `font-${settings.fontFamily}`;
            const sizeClass = `font-size-${settings.fontSize}`;

    // Remove any existing font/size classes
            bookContentEl.className.split(' ').forEach(c => {
                if (c.startsWith('font-')) {
                    bookContentEl.classList.remove(c);
                }
            });

    // Add the new classes
            bookContentEl.classList.add(fontClass);
            bookContentEl.classList.add(sizeClass);
        };

        const populateSettingsModal = () => {
            const currentSettings = loadSettings();

            // Populate Font Family Buttons
            fontFamilySelector.innerHTML = '';
            for (const key in FONT_OPTIONS) {
                const btn = document.createElement('button');
                btn.textContent = FONT_OPTIONS[key];
                btn.dataset.font = key;
                btn.className = `p-3 rounded-md text-white transition-colors choice-btn ${currentSettings.fontFamily === key ? 'bg-indigo-600 choice-btn-active' : 'bg-gray-700 hover:bg-gray-600'}`;
                btn.addEventListener('click', () => {
                    const newSettings = { ...loadSettings(), fontFamily: key };
                    saveSettings(newSettings);
                    applySettings();
                    populateSettingsModal(); // Repopulate to update active styles
                });
                fontFamilySelector.appendChild(btn);
            }

            // Populate Font Size Buttons
            fontSizeSelector.innerHTML = '';
            for (const key in FONT_SIZES) {
                const btn = document.createElement('button');
                btn.textContent = FONT_SIZES[key];
                btn.dataset.size = key;
                btn.className = `p-3 rounded-md text-white transition-colors choice-btn ${currentSettings.fontSize === key ? 'bg-indigo-600 choice-btn-active' : 'bg-gray-700 hover:bg-gray-600'}`;
                btn.addEventListener('click', () => {
                    const newSettings = { ...loadSettings(), fontSize: key };
                    saveSettings(newSettings);
                    applySettings();
                    populateSettingsModal();
                });
                fontSizeSelector.appendChild(btn);
            }
        };

        const getAnalysisKey = () => `typingAnalysis_${currentUsername}`;

        const loadAnalysis = () => {
            const saved = localStorage.getItem(getAnalysisKey());
            // The structure for storing all performance data
            const defaultStructure = { bigrams: {}, trigrams: {}, entryDelays: {} };
            if (saved) {
                return { ...defaultStructure, ...JSON.parse(saved) };
            }
            return defaultStructure;
        };

        const saveAnalysis = (data) => {
            if (!currentUsername) return;
            localStorage.setItem(getAnalysisKey(), JSON.stringify(data));
        };

        // Analyzes the paragraph's performance and saves it to the user's profile
		const analyzeAndSaveParagraphStats = () => {
			const analysis = loadAnalysis();
			const paragraphData = currentParagraphAnalysis;
			const currentWordCount = overallStats.cumulativeWordCount;

			// Ensure main analysis object has the right structure
			if (!analysis.bigrams) analysis.bigrams = {};
			if (!analysis.trigrams) analysis.trigrams = {};
			if (!analysis.metadata) analysis.metadata = {};

			// 1. Add new events from the just-completed paragraph
			for (const bigram in paragraphData.bigrams) {
				if (MASTER_BIGRAMS_200.includes(bigram)) {
					if (!analysis.bigrams[bigram]) analysis.bigrams[bigram] = { events: [] };
					paragraphData.bigrams[bigram].delays.forEach(delay => {
						analysis.bigrams[bigram].events.push({ type: 'delay', value: delay, wordCount: currentWordCount });
					});
					for (let i = 0; i < paragraphData.bigrams[bigram].errors; i++) {
						analysis.bigrams[bigram].events.push({ type: 'error', wordCount: currentWordCount });
					}
				}
			}
			for (const trigram in paragraphData.trigrams) {
				if (MASTER_TRIGRAMS_200.includes(trigram)) {
					if (!analysis.trigrams[trigram]) analysis.trigrams[trigram] = { events: [] };
					paragraphData.trigrams[trigram].delays.forEach(delay => {
						analysis.trigrams[trigram].events.push({ type: 'delay', value: delay, wordCount: currentWordCount });
					});
					for (let i = 0; i < paragraphData.trigrams[trigram].errors; i++) {
						analysis.trigrams[trigram].events.push({ type: 'error', wordCount: currentWordCount });
					}
				}
			}

			// 2. Perform Garbage Collection on the entire dataset
			const cutoffWordCount = Math.max(0, currentWordCount - 200);

			for (const bigram in analysis.bigrams) {
				analysis.bigrams[bigram].events = analysis.bigrams[bigram].events.filter(
					event => event.wordCount > cutoffWordCount
				);
				if (analysis.bigrams[bigram].events.length === 0) {
					delete analysis.bigrams[bigram];
				}
			}
			for (const trigram in analysis.trigrams) {
				analysis.trigrams[trigram].events = analysis.trigrams[trigram].events.filter(
					event => event.wordCount > cutoffWordCount
				);
				if (analysis.trigrams[trigram].events.length === 0) {
					delete analysis.trigrams[trigram];
				}
			}
			
			// 3. Update metadata and save
			analysis.metadata = { totalWordsTyped: currentWordCount };
			saveAnalysis(analysis);
		};

		const displayAnalysis = () => {
			const analysis = loadAnalysis();
			
			// Check for minimum word count
			const totalWordsTyped = analysis.metadata?.totalWordsTyped || 0;
			if (totalWordsTyped < 200) {
				weakBigramsList.innerHTML = `<p class="text-gray-500 text-sm">Type at least 200 words in your books to generate an analysis.</p>`;
				weakTrigramsList.innerHTML = `<p class="text-gray-500 text-sm">Keep practicing!</p>`;
				drillWeaknessesBtn.disabled = true;
				drillWeaknessesBtn.classList.add('opacity-50', 'cursor-not-allowed');
				return;
			}
			drillWeaknessesBtn.disabled = false;
			drillWeaknessesBtn.classList.remove('opacity-50', 'cursor-not-allowed');

			const getWeakestNgrams = (ngrams) => {
				return Object.entries(ngrams)
					.map(([ngram, data]) => {
						const recentDelays = data.events.filter(e => e.type === 'delay').map(e => e.value);
						const recentErrors = data.events.filter(e => e.type === 'error').length;
						const totalOccurrences = recentDelays.length + recentErrors;
						if (totalOccurrences === 0) return null;

						const avgCorrectDelay = recentDelays.length > 0 
							? recentDelays.reduce((a, b) => a + b, 0) / recentDelays.length 
							: 300;

						const errorPenalty = recentErrors * (avgCorrectDelay * 2);
						const totalTimeCost = recentDelays.reduce((a, b) => a + b, 0) + errorPenalty;
						const weaknessScore = totalTimeCost / totalOccurrences;

						return { ngram, averageDelay: weaknessScore, errors: recentErrors };
					})
					.filter(item => item !== null)
					.sort((a, b) => b.averageDelay - a.averageDelay)
					.slice(0, 5);
			};

			const weakBigrams = getWeakestNgrams(analysis.bigrams);
			const weakTrigrams = getWeakestNgrams(analysis.trigrams);

			weakBigramsList.innerHTML = '';
			weakTrigramsList.innerHTML = '';

			if (weakBigrams.length > 0) {
				weakBigrams.forEach(item => {
					const el = document.createElement('div');
					el.className = 'bg-gray-700 p-2 rounded-md flex justify-between items-center text-sm';
					el.innerHTML = `
						<span class="font-bold text-white">${item.ngram}</span>
						<span class="text-gray-400">${Math.round(item.averageDelay)}ms score, ${item.errors} err</span>
					`;
					weakBigramsList.appendChild(el);
				});
			} else {
				weakBigramsList.innerHTML = `<p class="text-gray-500 text-sm">Not enough recent data. Keep typing!</p>`;
			}
			
			if (weakTrigrams.length > 0) {
				weakTrigrams.forEach(item => {
					const el = document.createElement('div');
					el.className = 'bg-gray-700 p-2 rounded-md flex justify-between items-center text-sm';
					el.innerHTML = `
						<span class="font-bold text-white">${item.ngram}</span>
						<span class="text-gray-400">${Math.round(item.averageDelay)}ms score, ${item.errors} err</span>
					`;
					weakTrigramsList.appendChild(el);
				});
			} else {
				weakTrigramsList.innerHTML = `<p class="text-gray-500 text-sm">Not enough recent data. Keep typing!</p>`;
			}
		};

        // --- PROFILE MANAGEMENT ---
		
        const PROFILES_KEY = 'typingAppProfiles';
        const LAST_USER_KEY = 'typingAppLastUser';

        const getProfiles = () => JSON.parse(localStorage.getItem(PROFILES_KEY)) || [];
        const saveProfiles = (profiles) => localStorage.setItem(PROFILES_KEY, JSON.stringify(profiles));

        const setupUser = () => {
            const profiles = getProfiles();
            const lastUser = localStorage.getItem(LAST_USER_KEY);

            if (lastUser && profiles.includes(lastUser)) {
                loadProfile(lastUser);
            } else if (profiles.length > 0) {
                profileSwitcherModal.classList.remove('hidden');
                showProfileSwitcher();
            } else {
                profileModal.classList.remove('hidden');
            }
        };

        const loadProfile = (username) => {
            currentUsername = username;
            localStorage.setItem(LAST_USER_KEY, username);
            usernameDisplay.textContent = currentUsername;
            welcomeMessage.classList.remove('hidden');
            profileModal.classList.add('hidden');
            profileSwitcherModal.classList.add('hidden');
            renderLibrary();
        };

        const saveNewProfile = () => {
            const newUsername = usernameInput.value.trim();
            if (newUsername) {
                let profiles = getProfiles();
                if (profiles.includes(newUsername)) {
                    alert("A profile with this name already exists.");
                    return;
                }
                profiles.push(newUsername);
                saveProfiles(profiles);
                loadProfile(newUsername);
                usernameInput.value = '';
            }
        };
        
        const deleteProfile = (usernameToDelete) => {
            if (!confirm(`Are you sure you want to delete the profile "${usernameToDelete}"? All associated books and progress will be permanently lost.`)) return;

            Object.keys(localStorage)
                .filter(key => key.startsWith(`typingProgress_${usernameToDelete}_`) || key.startsWith(`typingLibrary_${usernameToDelete}`))
                .forEach(key => localStorage.removeItem(key));
            
            let profiles = getProfiles();
            const newProfiles = profiles.filter(p => p !== usernameToDelete);
            saveProfiles(newProfiles);

            if (currentUsername === usernameToDelete) {
                localStorage.removeItem(LAST_USER_KEY);
                location.reload();
            } else {
                showProfileSwitcher(); // Refresh the list
            }
        };

        const showProfileSwitcher = () => {
            const profiles = getProfiles();
            profileListContainer.innerHTML = '';
            if (profiles.length === 0) {
                profileListContainer.innerHTML = `<p class="text-gray-400 text-center">No profiles found. Please create one.</p>`;
            } else {
                profiles.forEach(username => {
                    const profileItem = document.createElement('div');
                    profileItem.className = 'flex justify-between items-center bg-gray-700 p-3 rounded-md';
                    profileItem.innerHTML = `
                        <span class="font-medium text-white">${username}</span>
                        <div class="space-x-2">
                            <button data-username="${username}" class="load-profile-btn bg-blue-600 hover:bg-blue-700 text-white font-bold py-1 px-3 rounded-md text-sm">Load</button>
                            <button data-username="${username}" class="delete-profile-btn bg-red-600 hover:bg-red-700 text-white font-bold py-1 px-3 rounded-md text-sm">Delete</button>
                        </div>
                    `;
                    profileListContainer.appendChild(profileItem);
                });
            }
            profileSwitcherModal.classList.remove('hidden');
        };

        const getProgressSaveKey = () => `typingProgress_${currentUsername}_${currentBookIdentifier}`;
        const getLibrarySaveKey = () => `typingLibrary_${currentUsername}`;

        const saveProgress = () => {
            if (!currentUsername || !currentBookIdentifier) return;
            const progress = {
                currentChapterIndex,
                currentParagraphIndexInChapter,
                overallStats,
                history,
                lastUpdated: Date.now()
            };
            localStorage.setItem(getProgressSaveKey(), JSON.stringify(progress));
        };

        const loadProgress = () => {
            const savedData = localStorage.getItem(getProgressSaveKey());
            if (savedData) {
                const progress = JSON.parse(savedData);
                currentChapterIndex = progress.currentChapterIndex;
                currentParagraphIndexInChapter = progress.currentParagraphIndexInChapter;
                overallStats = progress.overallStats;
                history = progress.history;
        
                if (!history.paragraphWordCounts) history.paragraphWordCounts = [];
                if (!history.cumulativeWordsInChapter) history.cumulativeWordsInChapter = [];
                if (!history.rawTimes) history.rawTimes = [];
                if (!history.rawCorrectChars) history.rawCorrectChars = [];
                if (!history.rawTypedChars) history.rawTypedChars = [];
        
                return true;
            }

            // If no saved data is found, reset stats as normal
            history = { wpm: [], accuracy: [], labels: [], overallWpmHistory: [], cumulativeWords: [], chapterIndices: [], paragraphWordCounts: [], cumulativeWordsInChapter: [], rawTimes: [], rawCorrectChars: [], rawTypedChars: [] };
            overallStats = { totalCorrectChars: 0, totalTypedChars: 0, totalTime: 0, cumulativeWordCount: 0 };
            return false;
        };

        // --- LIBRARY MANAGEMENT ---
        const getLibrary = () => JSON.parse(localStorage.getItem(getLibrarySaveKey())) || [];
        const saveLibrary = (library) => localStorage.setItem(getLibrarySaveKey(), JSON.stringify(library));

		const renderLibrary = () => {
			const library = getLibrary();
			libraryList.innerHTML = '';
			if (library.length === 0) {
				libraryList.className = 'text-center col-span-full';
				libraryList.innerHTML = `<p class="text-gray-400">Your library is empty. Add a book to get started!</p>`;
			} else {
				libraryList.className = 'grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-6';
				library.forEach((book, index) => {
					const bookElement = document.createElement('div');
					bookElement.className = 'library-book-card bg-gray-800 rounded-lg flex flex-col text-center shadow-lg overflow-hidden';
					
					// This is the updated HTML for each book card
					bookElement.innerHTML = `
						<img src="${book.cover || 'https://via.placeholder.com/300x450.png?text=No+Cover'}" alt="Cover for ${book.bookName}" class="w-full h-auto">
						
						<div class="p-4 flex flex-col flex-grow w-full">
							<h3 class="font-bold text-white text-md leading-tight mb-1 truncate" title="${book.bookName}">${book.bookName}</h3>
							<p class="text-gray-400 text-sm mb-4 truncate" title="${book.author}">${book.author}</p>
							
							<div class="mt-auto space-y-2 w-full">
								<button data-index="${index}" class="start-typing-btn w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-3 rounded-md text-sm">Type</button>
								<button data-index="${index}" class="delete-book-btn w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-3 rounded-md text-sm">Delete</button>
							</div>
						</div>
					`;
					libraryList.appendChild(bookElement);
				});
			}
		};
		
        const deleteBook = (index) => {
             let library = getLibrary();
             const bookToDelete = library[index];
            if (!confirm(`Are you sure you want to delete "${bookToDelete.bookName}" from your library?`)) return;
            // Remove progress file
            localStorage.removeItem(`typingProgress_${currentUsername}_${bookToDelete.identifier}`);
            // Remove from library
            library.splice(index, 1);
            saveLibrary(library);
            renderLibrary();
        };

        // --- UI NAVIGATION ---
        const showLibraryView = () => {
            libraryView.classList.remove('hidden');
            fileLoaderSection.classList.add('hidden');
            typingAppSection.classList.add('hidden');
            typingAppSection.classList.remove('flex');
            appTitleHeader.classList.remove('hidden');
            bookTitleHeader.classList.add('hidden');
            bookTitleHeader.innerHTML = '';
        };

        const showFileLoaderView = () => {
            libraryView.classList.add('hidden');
            fileLoaderSection.classList.remove('hidden');
            typingAppSection.classList.add('hidden');
            typingAppSection.classList.remove('flex');
        };
        
        const showTypingView = () => {
            libraryView.classList.add('hidden');
            fileLoaderSection.classList.add('hidden');
            typingAppSection.classList.remove('hidden');
            typingAppSection.classList.add('flex');
            appTitleHeader.classList.add('hidden');
            bookTitleHeader.classList.remove('hidden');
        };
		
		const showDrillView = () => {
			libraryView.classList.add('hidden');
			fileLoaderSection.classList.add('hidden');
			typingAppSection.classList.add('hidden');
			typingAppSection.classList.remove('flex');
			analysisModal.classList.add('hidden');

			drillModeSection.classList.remove('hidden');
			drillModeSection.classList.add('flex');

			appTitleHeader.classList.add('hidden');
			bookTitleHeader.classList.remove('hidden'); // Keep the main book title visible
		};

		const startDrill = () => {
			isDrillActive = true;
			currentParagraphIndexInChapter = -1;
			currentContentEl = drillContentEl;

			const analysis = loadAnalysis();
			
			const totalWordsTyped = analysis.metadata?.totalWordsTyped || 0;
			if (totalWordsTyped < 200) {
				alert("You need to type at least 200 words before you can use the drill feature.");
				analysisModal.classList.add('hidden');
				return;
			}

			const getWeakest = (ngrams) => {
				return Object.entries(ngrams)
					.map(([ngram, data]) => {
						const recentDelays = data.events.filter(e => e.type === 'delay').map(e => e.value);
						const recentErrors = data.events.filter(e => e.type === 'error').length;
						const totalOccurrences = recentDelays.length + recentErrors;
						if (totalOccurrences === 0) return null;
						const avgCorrectDelay = recentDelays.length > 0 ? recentDelays.reduce((a, b) => a + b, 0) / recentDelays.length : 300;
						const errorPenalty = recentErrors * (avgCorrectDelay * 2);
						const totalTimeCost = recentDelays.reduce((a, b) => a + b, 0) + errorPenalty;
						const score = totalTimeCost / totalOccurrences;
						return { ngram, weaknessScore: score };
					})
					.filter(item => item !== null)
					.sort((a, b) => b.weaknessScore - a.weaknessScore)
					.slice(0, 10);
			};

			const weakBigrams = getWeakest(analysis.bigrams);
			const weakTrigrams = getWeakest(analysis.trigrams);

			const tier1Weaknesses = [...weakBigrams.slice(0, 5), ...weakTrigrams.slice(0, 5)].sort((a, b) => b.weaknessScore - a.weaknessScore);
			const tier2Weaknesses = [...weakBigrams.slice(5, 10), ...weakTrigrams.slice(5, 10)];

			if (tier1Weaknesses.length === 0) {
				alert("Not enough analysis data from the last 200 words. Please type a few more paragraphs.");
				isDrillActive = false;
				analysisModal.classList.add('hidden');
				return;
			}

			const DRILL_SIZE = 50;
			let practiceSet = [];
			const usedWords = new Set();
			const totalTier1Score = tier1Weaknesses.reduce((sum, item) => sum + item.weaknessScore, 0);

			if (totalTier1Score > 0) {
				tier1Weaknesses.forEach(weakness => {
					const wordCountForThisNgram = Math.round((weakness.weaknessScore / totalTier1Score) * DRILL_SIZE);
					if (wordCountForThisNgram < 1) return;
					// Use the new 2k list
					const matchingWords = MASTER_WORDS_2K.filter(word => word.includes(weakness.ngram) && !usedWords.has(word));
					matchingWords.sort(() => 0.5 - Math.random());
					const wordsToAdd = matchingWords.slice(0, wordCountForThisNgram);
					wordsToAdd.forEach(word => {
						practiceSet.push(word);
						usedWords.add(word);
					});
				});
			}

			if (practiceSet.length < DRILL_SIZE && tier2Weaknesses.length > 0) {
				const remainingNeeded = DRILL_SIZE - practiceSet.length;
				// Use the new 2k list
				const tier2MatchingWords = MASTER_WORDS_2K.filter(word => tier2Weaknesses.some(w => word.includes(w.ngram)) && !usedWords.has(word));
				tier2MatchingWords.sort(() => 0.5 - Math.random());
				practiceSet.push(...tier2MatchingWords.slice(0, remainingNeeded));
			}

			if (practiceSet.length < DRILL_SIZE) {
				const remainingNeeded = DRILL_SIZE - practiceSet.length;
				// Use the new 2k list
				const randomFillWords = MASTER_WORDS_2K.filter(word => !usedWords.has(word)).sort(() => 0.5 - Math.random()).slice(0, remainingNeeded);
				practiceSet.push(...randomFillWords);
			}
			
			practiceSet.sort(() => 0.5 - Math.random());
			const drillSet = practiceSet.slice(0, DRILL_SIZE);
			
			drillTotalWords = drillSet.length;

			const drillParagraph = drillSet.join(' ');
			drillTargetLength = drillParagraph.length;
			currentChapterParagraphs = [{ text: drillParagraph, html: drillParagraph }];
			const totalWeaknesses = tier1Weaknesses.length + tier2Weaknesses.length;
			chapterStatsDisplay.textContent = `Drilling ${totalWeaknesses} identified weaknesses.`;
			chapterSelectorContainer.classList.add('hidden');
			drillWordCount.textContent = `0 / ${drillTotalWords}`;

			showDrillView();
			renderDrill();
			activateNextParagraph(true);
		};

		const createFanfareText = (text) => {
			return text.split('').map(char => {
				if (char === ' ') { return ' '; } // Keep spaces as normal characters
				const delay = (Math.random() * -1.5).toFixed(2);
				return `<span class="fanfare-char" style="animation-delay: ${delay}s;">${char}</span>`;
			}).join('');
		};

		const finishDrill = () => {
			if (!isDrillActive) return;

			const totalTime = (paragraphKeyPressLog.length > 1) ? (paragraphKeyPressLog[paragraphKeyPressLog.length - 1].time - paragraphKeyPressLog[0].time) / 1000 : 0;
			const typedChars = currentUserInput.length;
			let correctChars = 0;
			const sourceText = currentChapterParagraphs[0].text;
			for (let i = 0; i < typedChars; i++) {
				if (currentUserInput[i] === sourceText[i]) correctChars++;
			}

			const finalWPM = (totalTime > 0) ? ((typedChars / CHARS_PER_WORD) / (totalTime / 60)) : 0;
			const finalAccuracy = (typedChars > 0) ? (correctChars / typedChars) * 100 : 0;

			drillWpmDisplay.textContent = finalWPM.toFixed(1);
			drillAccuracyDisplay.textContent = `${finalAccuracy.toFixed(0)}%`;
			
			drillWordCount.textContent = `${drillTotalWords} / ${drillTotalWords}`;

			isDrillActive = false;
			currentContentEl = bookContentEl;
			
			const fanfareText = createFanfareText("Drill Complete! Good job!");

			drillContentEl.innerHTML = `
				<div class="text-center p-8 rounded-lg">
					<h2 class="text-3xl font-bold text-green-400 mb-4 ui-subheading">${fanfareText}</h2>
					<div class="flex justify-center space-x-8 mt-4">
						<div>
							<p class="text-sm text-gray-400">WPM</p>
							<div class="text-3xl font-bold text-green-400">${finalWPM.toFixed(1)}</div>
						</div>
						<div>
							<p class="text-sm text-gray-400">Accuracy</p>
							<div class="text-3xl font-bold text-sky-400">${finalAccuracy.toFixed(0)}%</div>
						</div>
					</div>
				</div>
			`;
		};
		
        // --- HELPER FUNCTION TO CONVERT BLOB URL TO BASE64 ---
        const blobUrlToBase64 = (url) => {
            return new Promise((resolve, reject) => {
                if (!url) {
                    resolve(null);
                    return;
                }
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                fetch(url)
                    .then(res => res.blob())
                    .then(blob => reader.readAsDataURL(blob))
                    .catch(reject);
            });
        };

        // --- FILE LOADING & CHAPTER PARSING ---
		const handleFile = async (file) => {
			if (file && file.name.endsWith('.epub')) {
				loadingStatus.textContent = 'Loading EPUB...';
				isBookLoading = true;
				try {
					const book = ePub(file);
					await book.ready;
					
					const metadata = book.packaging.metadata;
					let coverBase64 = null; // Default the cover to null

					// New: Gracefully attempt to load the cover
					try {
						const coverUrl = await book.coverUrl();
						if (coverUrl) { // Only proceed if a cover URL was actually found
							coverBase64 = await blobUrlToBase64(coverUrl);
						}
					} catch (coverError) {
						console.warn("Could not load cover for this EPUB, proceeding without it:", coverError);
					}

					const allSections = [];
					const MIN_TEXT_LENGTH = 200;

					const processTocItems = async (tocItems) => {
						for (const item of tocItems) {
							const cleanHref = item.href.split('#')[0];
							const doc = await book.load(cleanHref);
							const body = doc.body || doc.documentElement;
							const htmlContent = body.innerHTML;

							const tempDiv = document.createElement('div');
							tempDiv.innerHTML = htmlContent;
							const textContent = (tempDiv.textContent || "").trim();
							
							if (textContent.length > MIN_TEXT_LENGTH) {
								allSections.push({
									title: item.label.trim(),
									htmlContent: htmlContent
								});
							}

							if (item.subitems && item.subitems.length > 0) {
								await processTocItems(item.subitems);
							}
						}
					};

					await processTocItems(book.navigation.toc);
					
					prepareBookForSelection(metadata, coverBase64, allSections);
				} catch (error) {
					loadingStatus.textContent = `Error processing EPUB file: ${error.message}`;
					console.error(error);
				} finally {
					isBookLoading = false;
				}
			} else {
				alert('Please select or drop a valid .epub file.');
			}
		};
		
        const prepareBookForSelection = (metadata, cover, allSections) => {
            // Store all extracted data temporarily
            tempBookData.title = metadata.title;
            tempBookData.author = metadata.creator;
            tempBookData.cover = cover; // Storing Base64 string
            tempBookData.identifier = `${metadata.title}-${metadata.creator}`.replace(/\s+/g, '-'); // Create a unique ID
            tempBookData.chapterMarkers = allSections;

            // Populate and show the modal
            chapterListContainer.innerHTML = '';
            tempBookData.chapterMarkers.forEach((marker, index) => {
                const item = document.createElement('div');
                item.className = 'flex justify-between items-center p-3 bg-gray-700 rounded-md mb-2';
                item.innerHTML = `
                    <span class="text-gray-300 truncate">${marker.title}</span>
                    <div class="flex space-x-2" data-index="${index}">
                        <button class="choice-btn bg-green-600 hover:bg-green-700 text-white font-bold py-1 px-3 rounded-md text-sm choice-btn-active" data-choice="type">Type</button>
                        <button class="choice-btn bg-gray-500 hover:bg-gray-600 text-white font-bold py-1 px-3 rounded-md text-sm" data-choice="skip">Skip</button>
                    </div>
                `;
                chapterListContainer.appendChild(item);
            });
            
            chapterSelectionModal.classList.remove('hidden');
            loadingStatus.textContent = '';
        };

        // --- CHAPTER AND PARAGRAPH MANAGEMENT ---
        const countWords = (text) => {
            return text.split(/[\s-]+/).filter(w => w.length > 0).length;
        };

        const normalizeText = (text) => {
            if (!text) return '';
            return text
			    .replace(/[\u201C\u201D]/g, '"')      // Curly Double Quotes: ‚Äú ‚Äù ‚Üí "
                .replace(/[¬´¬ª]/g, '"')             // French Guillemets: ¬´ ¬ª ‚Üí "
                .replace(/[\u2018\u2019]/g, "'")      // Curly Single Quotes: ‚Äò ‚Äô ‚Üí '
                .replace(/[\u2013\u2014]/g, '-')      // En & Em Dashes: ‚Äì ‚Äî ‚Üí -
                .replace(/\u2026/g, '...')          // Ellipsis Character: ‚Ä¶ ‚Üí ...
                .replace(/\.\s\.\s\./g, '...');    // Spaced Ellipsis: . . . ‚Üí ...
        };

        const startTypingBook = (book) => {
            currentBookIdentifier = book.identifier;
            bookTitleHeader.innerHTML = `${book.bookName}<br><span class="text-3xl text-indigo-300 font-normal" style="font-family: 'Cormorant Garamond', serif;">By ${book.author}</span>`;
    
            chapterMarkers = book.chapterMarkers.filter((marker, index) => {
                const choice = book.userChapterChoices[index];
                return choice && choice.status === 'type';
            });
    
            chapterSelector.innerHTML = '';
            chapterMarkers.forEach((marker, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = marker.title;
                chapterSelector.appendChild(option);
            });
            chapterSelectorContainer.classList.remove('hidden');
            
			showTypingView();
			
            applySettings(); // Apply user's font/size settings

            const resumed = loadProgress();

            if (!resumed) {
        // If not resuming, it's a fresh start. Reset position indices.
                currentChapterIndex = 0;
                currentParagraphIndexInChapter = -1;
                bookContentEl.scrollTop = 0;
            }
    
            initializeChart();
            loadChapter(resumed ? currentChapterIndex : 0, resumed);
        };

		const loadChapter = (chapterIndex, isResuming = false) => {
			if (chapterIndex >= chapterMarkers.length) {
				bookContentEl.innerHTML = `<h2 class="text-center text-green-400 text-3xl font-bold mt-8">Congratulations! You've finished all selected chapters.</h2>`;
				chapterStatsDisplay.textContent = '';
				return;
			}

			const isNewChapter = currentChapterIndex !== chapterIndex;
			currentChapterIndex = chapterIndex;
			chapterSelector.value = chapterIndex;

			const marker = chapterMarkers[currentChapterIndex];
			const chapterHtml = marker.htmlContent;
			const tempDiv = document.createElement('div');
			tempDiv.innerHTML = chapterHtml;

			let paragraphElements = Array.from(tempDiv.querySelectorAll('p'));
			if (paragraphElements.filter(p => (p.textContent || "").trim()).length < 3) {
				currentChapterParagraphs = (tempDiv.textContent || "")
					.split(/\n\s*\n+/)
					.map(text => text.trim())
					.filter(text => text.length > 0)
					.map(text => {
						const cleanText = normalizeText(text);
						return { html: cleanText, text: cleanText };
					});
			} else {
				currentChapterParagraphs = paragraphElements.map(p_el => {
					const rawText = p_el.textContent || "";
					const cleanText = normalizeText(rawText.replace(/\s+/g, ' ').trim());
					return { html: cleanText, text: cleanText };
				}).filter(p => p.text.length > 0);
			}

			const chapterWordCount = countWords(currentChapterParagraphs.map(p => p.text).join(' '));
			currentChapterWordCount = chapterWordCount;
			chapterStatsDisplay.innerHTML = `Current Chapter: <span class="font-bold text-white" style="font-family: 'Noto Sans', sans-serif;">${marker.title}</span> | Total Words: <span class="font-bold text-white">${chapterWordCount}</span>`;
			
			const paragraphsDone = history.chapterIndices.filter(i => i === currentChapterIndex).length;
			paragraphCountDisplay.textContent = `${paragraphsDone} / ${currentChapterParagraphs.length}`;

			renderChapter(isResuming);

			if (isResuming) {
				const paragraphsDoneInChapter = history.chapterIndices.filter(i => i === currentChapterIndex).length;
				const lastValidIndex = Math.max(0, currentChapterParagraphs.length - 1);
				currentParagraphIndexInChapter = Math.min(paragraphsDoneInChapter, lastValidIndex);
				activateNextParagraph(false);
			} else {
				if (isNewChapter) currentParagraphIndexInChapter = -1;
				activateNextParagraph(true);
			}
		};

    // --- END OF LOGIC ---

		const renderChapter = (isResuming) => {
			let html = '';
			// Only render the chapter heading if we are NOT in a drill
			if (!isDrillActive) {
				html += `<h2 class="chapter-heading text-3xl font-bold text-gray-400">${chapterMarkers[currentChapterIndex].title}</h2>`;
			}

			currentChapterParagraphs.forEach((p, index) => {
				const chars = wrapCharsInSpans(p.html);
				html += `<div class="paragraph-block" data-paragraph-index="${index}">${chars}<span class="end-cursor-target"></span></div>`;
			});
			currentContentEl.innerHTML = html;
			currentContentEl.scrollTop = 0;

			if (isResuming) {
				highlightCompletedParagraphs();
				updateChart();
			}
		};
		
		const renderDrill = () => {
			const drillText = currentChapterParagraphs[0].html;
			const chars = wrapCharsInSpans(drillText);
			// Directly target the drill content element to avoid confusion
			drillContentEl.innerHTML = `<div class="paragraph-block" data-paragraph-index="0">${chars}<span class="end-cursor-target"></span></div>`;
			drillContentEl.scrollTop = 0;
		};

        const highlightCompletedParagraphs = () => {
		// Find all history entries that correspond to the current chapter
            const historyIndicesForChapter = history.chapterIndices
                .map((chapIdx, i) => ({ chapIdx, historyIndex: i }))
                .filter(item => item.chapIdx === currentChapterIndex);

		// Loop through the completed paragraphs and apply the correct style based on history
            historyIndicesForChapter.forEach((item, paraIndexInChapter) => {
                const paragraphEl = document.querySelector(`[data-paragraph-index="${paraIndexInChapter}"]`);
                if (paragraphEl) {
                    const wasSkipped = history.wpm[item.historyIndex] === null;
                    const styleClass = wasSkipped ? 'char-span skipped' : 'char-span correct';
                    paragraphEl.querySelectorAll('.char-span').forEach(span => span.className = styleClass);
                }
            });
        };

		const activateNextParagraph = (shouldIncrement = true) => {
			resetParagraphState();
			if (shouldIncrement) {
				currentParagraphIndexInChapter++;
			}

			if (currentParagraphIndexInChapter >= currentChapterParagraphs.length) {
				loadChapter(currentChapterIndex + 1);
				return;
			}

			const paragraphEl = currentContentEl.querySelector(`[data-paragraph-index="${currentParagraphIndexInChapter}"]`);
			if (paragraphEl) {
				const topPos = paragraphEl.getBoundingClientRect().top - currentContentEl.getBoundingClientRect().top + currentContentEl.scrollTop;
				currentContentEl.scrollTop = topPos;

				currentContentEl.focus({ preventScroll: true }); 
				startTest();
				setTimeout(updateCursor, 0);
			}
		};

        const skipParagraph = () => {
    // Highlight the skipped paragraph
            const paragraphEl = document.querySelector(`[data-paragraph-index="${currentParagraphIndexInChapter}"]`);
            if (paragraphEl) {
                paragraphEl.querySelectorAll('.char-span').forEach(span => span.className = 'char-span skipped');
            }

    // Add a placeholder record to history so we can go back to it
            history.wpm.push(null); // Using null indicates a skip
            history.accuracy.push(null);
            history.labels.push(`S${history.labels.length + 1}`); // "S" for Skipped
    
    // Add zero values for raw stats, so "go back" works correctly
            history.rawTimes.push(0);
            history.rawCorrectChars.push(0);
            history.rawTypedChars.push(0);

    // Overall stats don't change, so we carry over the previous values
            const lastOverallWpm = history.overallWpmHistory.length > 0 ? history.overallWpmHistory[history.overallWpmHistory.length - 1] : 0;
            history.overallWpmHistory.push(lastOverallWpm);
            history.cumulativeWords.push(overallStats.cumulativeWordCount); // Word count doesn't increase

    // Record the location
            history.chapterIndices.push(currentChapterIndex);
    
    // For chart consistency, don't advance the word count on the x-axis for a skip
            const lastCumulativeWordsInChapter = history.cumulativeWordsInChapter.length > 0 ? history.cumulativeWordsInChapter[history.cumulativeWordsInChapter.length-1] : 0;
            history.cumulativeWordsInChapter.push(lastCumulativeWordsInChapter);
            history.paragraphWordCounts.push(0); // 0 words were contributed

    // Update the UI
            const paragraphsDone = history.chapterIndices.filter(i => i === currentChapterIndex).length;
            paragraphCountDisplay.textContent = `${paragraphsDone} / ${currentChapterParagraphs.length}`;
            updateChart(); // This will register the "null" data point, creating a gap in the chart

    // Move to the next paragraph
            activateNextParagraph(true);
            saveProgress();
        };

        // --- TYPING LOGIC ---

        const resetParagraphState = () => {
            isTestActive = false;
            paragraphKeyPressLog = [];
            liveAccuracyLog = [];
            currentUserInput = '';
            liveWpmDisplay.textContent = '0';
            liveAccuracyDisplay.textContent = '100%';
			// Clear the analysis for the new paragraph
			currentParagraphAnalysis = {
			    bigrams: {},
				trigrams: {},
				entryDelays: {}
			};
        };
		
		const logKeyPressAnalysis = (key, isCorrect) => {
			const isLetter = /^[a-zA-Z]$/.test(key);
			if (!isLetter) return;

			const log = paragraphKeyPressLog;
			const input = currentUserInput;
			const analysis = currentParagraphAnalysis;

			let lastTimestamp = log.length > 0 ? log[log.length - 1].time : 0;
			const delay = lastTimestamp ? Date.now() - lastTimestamp : 0;

			const charIndex = input.length;

			// 1. Analyze Bigrams
			if (charIndex >= 1) {
				const prevChar = input[charIndex - 1];
				if (/^[a-zA-Z]$/.test(prevChar)) {
					const rawBigram = `${prevChar}${key}`;
					const bigram = rawBigram.toLowerCase();

					if (!analysis.bigrams[bigram]) {
						analysis.bigrams[bigram] = { delays: [], errors: 0 };
					}
					// Only log the delay if no capital letters were involved
					if (!/[A-Z]/.test(rawBigram)) {
						analysis.bigrams[bigram].delays.push(delay);
					}
					if (!isCorrect) {
						analysis.bigrams[bigram].errors++;
					}

					// 2. Analyze Entry Delay
					const charBefore = input[charIndex - 2] || ' ';
					if (charBefore === ' ') {
						const firstLetter = prevChar.toLowerCase();
						if (!analysis.entryDelays[firstLetter]) {
							analysis.entryDelays[firstLetter] = [];
						}
						const lastSpaceEvent = log.slice().reverse().find(e => e.char === ' ');
						if (lastSpaceEvent) {
							const entryDelay = log[log.length - 1].time - lastSpaceEvent.time;
							analysis.entryDelays[firstLetter].push(entryDelay);
						}
					}
				}
			}

			// 3. Analyze Trigrams
			if (charIndex >= 2) {
				const prevChar1 = input[charIndex - 2];
				const prevChar2 = input[charIndex - 1];
				if (/^[a-zA-Z]$/.test(prevChar1) && /^[a-zA-Z]$/.test(prevChar2)) {
					const rawTrigram = `${prevChar1}${prevChar2}${key}`;
					const trigram = rawTrigram.toLowerCase();

					if (!analysis.trigrams[trigram]) {
						analysis.trigrams[trigram] = { delays: [], errors: 0 };
					}
					// Only log the delay if no capital letters were involved
					if (!/[A-Z]/.test(rawTrigram)) {
						const delay2 = log[log.length - 1].time - log[log.length - 2].time;
						analysis.trigrams[trigram].delays.push(delay + delay2);
					}
					 if (!isCorrect) {
						analysis.trigrams[trigram].errors++;
					}
				}
			}
		};

        const startTest = () => {
            isTestActive = true;
        };

		const handleKeyPress = (e) => {
			const activeEl = document.activeElement;
			if (!profileModal.classList.contains('hidden') || !profileSwitcherModal.classList.contains('hidden') || !settingsModal.classList.contains('hidden')) { return; }
			if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA' || activeEl.isContentEditable)) { return; }
			if (isBookLoading || !typingAppSection.classList.contains('hidden') || !drillModeSection.classList.contains('hidden')) e.preventDefault();
			if (isBookLoading) return;
			if (currentParagraphIndexInChapter < 0 || currentParagraphIndexInChapter >= currentChapterParagraphs.length) return;

			const paragraphObject = currentChapterParagraphs[currentParagraphIndexInChapter];
			if (!paragraphObject) return;
			const currentParagraphText = paragraphObject.text;
			if (!currentParagraphText) return;

			if (e.key === 'Enter') {
				if (isDrillActive) return; // Enter does nothing in drill mode
				if (e.shiftKey) { skipParagraph(); return; }
				if (currentUserInput.length === currentParagraphText.length && isTestActive) {
					finishParagraph();
				}
				return;
			} else if (e.key === 'Tab') {
				if (e.shiftKey) {
					if (currentUserInput.length === 0) goToPreviousParagraph();
					return;
				}
				resetParagraphState();
				const paragraphEl = currentContentEl.querySelector(`[data-paragraph-index="${currentParagraphIndexInChapter}"]`);
				if (paragraphEl) {
					paragraphEl.querySelectorAll('.char-span').forEach(span => span.className = 'char-span untyped');
				}
				activateNextParagraph(false);
			} else if (e.key === 'Backspace') {
				if (currentUserInput.length > 0) {
					currentUserInput = currentUserInput.slice(0, -1);
					paragraphKeyPressLog.push({ char: 'Backspace', time: Date.now() });
				}
			} else if (e.key.length === 1) {
				if (!isTestActive) startTest();
				if (currentUserInput.length < currentParagraphText.length) {
					const isCorrect = currentParagraphText[currentUserInput.length] === e.key;
					logKeyPressAnalysis(e.key, isCorrect);
					currentUserInput += e.key;
					paragraphKeyPressLog.push({ char: e.key, time: Date.now() });
					liveAccuracyLog.push(isCorrect);

					// Auto-finish logic for drills
					if (isDrillActive && currentUserInput.length === drillTargetLength) {
						finishDrill();
					}
				}
			}

			updateHighlighting();
			updateCursor();
			updateLiveStats();
		};

        // --- UI & STATS UPDATES ---

		const updateLiveStats = () => {
			if (!isTestActive) return;

			const now = Date.now();
			const recentKeyPresses = paragraphKeyPressLog.slice(-40);
			let wpm = 0;
			let accuracy = 100;

			if (recentKeyPresses.length > 5) {
				const timeSpan = (now - recentKeyPresses[0].time) / 1000;
				if (timeSpan > 0) {
					wpm = (recentKeyPresses.length / CHARS_PER_WORD) / (timeSpan / 60);
				}
			}

			if (liveAccuracyLog.length > 0) {
				const recentAccuracyLog = liveAccuracyLog.slice(-40);
				const correctCount = recentAccuracyLog.filter(Boolean).length;
				accuracy = (correctCount / recentAccuracyLog.length) * 100;
			}

			if (isDrillActive) {
				drillWpmDisplay.textContent = wpm > 0 ? Math.round(wpm) : '0';
				drillAccuracyDisplay.textContent = `${Math.round(accuracy)}%`;
				
				let wordsTyped = 0;
				const sourceText = currentChapterParagraphs[0].text;
				
				if (currentUserInput.length > 0) {
					// Get the slice of the source text that the cursor has passed
					const progressText = sourceText.substring(0, currentUserInput.length);
					// The number of completed words is the number of spaces they have passed
					wordsTyped = (progressText.match(/ /g) || []).length;
				}
		
				// When the user has typed all characters, set the count to the known total
				if (currentUserInput.length === sourceText.length) {
					wordsTyped = drillTotalWords;
				}
				
				drillWordCount.textContent = `${wordsTyped} / ${drillTotalWords}`;
			} else {
				liveWpmDisplay.textContent = wpm > 0 ? Math.round(wpm) : '0';
				liveAccuracyDisplay.textContent = `${Math.round(accuracy)}%`;
			}
		};

		const finishParagraph = () => {
			const sourceText = currentChapterParagraphs[currentParagraphIndexInChapter].text;
			if (paragraphKeyPressLog.length < 2) {
				activateNextParagraph();
				return;
			};
			const timeElapsed = (paragraphKeyPressLog[paragraphKeyPressLog.length - 1].time - paragraphKeyPressLog[0].time) / 1000;

			let correctChars = 0;
			for (let i = 0; i < currentUserInput.length; i++) {
				if (sourceText[i] === currentUserInput[i]) correctChars++;
			}
			const typedChars = currentUserInput.length;
			const paragraphWPM = ((typedChars / CHARS_PER_WORD) / (timeElapsed / 60)) || 0;
			const paragraphAccuracy = Math.round((correctChars / sourceText.length) * 100) || 0;

			// --- LOGIC FOR DRILL MODE ---
			if (isDrillActive) {
				// Update the drill-specific stat displays
				drillWpmDisplay.textContent = paragraphWPM.toFixed(1);
				drillAccuracyDisplay.textContent = `${paragraphAccuracy}%`;

				// Display the completion message in the content area
				currentContentEl.innerHTML = `
					<div class="text-center p-8">
						<h2 class="text-3xl font-bold text-green-400 mb-4 ui-subheading">Drill Complete!</h2>
						<p class="text-xl text-gray-300">Your stats for that set:</p>
						<div class="flex justify-center space-x-8 mt-4">
							<div>
								<p class="text-sm text-gray-400">WPM</p>
								<div class="text-3xl font-bold text-green-400">${paragraphWPM.toFixed(1)}</div>
							</div>
							<div>
								<p class="text-sm text-gray-400">Accuracy</p>
								<div class="text-3xl font-bold text-sky-400">${paragraphAccuracy}%</div>
							</div>
						</div>
					</div>
				`;
				return; // Stop the function here to prevent loading a new paragraph
			}

			// This part below only runs for normal book typing
			const paragraphWordCount = countWords(sourceText);
			history.rawTimes.push(timeElapsed);
			history.rawCorrectChars.push(correctChars);
			history.rawTypedChars.push(typedChars);
			history.paragraphWordCounts.push(paragraphWordCount);
			history.chapterIndices.push(currentChapterIndex);

			let currentChapterCumulative = 0;
			for (let i = 0; i < history.paragraphWordCounts.length; i++) {
				if (history.chapterIndices[i] === currentChapterIndex) {
					currentChapterCumulative += history.paragraphWordCounts[i];
				}
			}
			history.cumulativeWordsInChapter.push(currentChapterCumulative);
			overallStats.cumulativeWordCount += paragraphWordCount;
			overallStats.totalCorrectChars += correctChars;
			overallStats.totalTypedChars += typedChars;
			overallStats.totalTime += timeElapsed;
			const overallWPM = ((overallStats.totalTypedChars / CHARS_PER_WORD) / (overallStats.totalTime / 60)) || 0;
			const overallAccuracy = Math.round((overallStats.totalCorrectChars / overallStats.totalTypedChars) * 100) || 0;
			overallWpmDisplay.textContent = overallWPM.toFixed(1);
			overallAccuracyDisplay.textContent = `${overallAccuracy}%`;
			const newCount = history.labels.length + 1;
			history.wpm.push(paragraphWPM);
			history.accuracy.push(paragraphAccuracy);
			history.overallWpmHistory.push(overallWPM);
			history.cumulativeWords.push(overallStats.cumulativeWordCount);
			history.labels.push(`P${newCount}`);
			paragraphCountDisplay.textContent = `${history.chapterIndices.filter(i => i === currentChapterIndex).length} / ${currentChapterParagraphs.length}`;
			analyzeAndSaveParagraphStats();
			updateChart();
			activateNextParagraph();
			saveProgress();
		};

        const goToPreviousParagraph = () => {
            // Check if there's any history to go back to.
            if (history.wpm.length === 0) return;

            // 1. Get info about the last completed paragraph BEFORE modifying history.
            const chapterOfLastParagraph = history.chapterIndices[history.chapterIndices.length - 1];
            
            // 2. Calculate the index (within its chapter) of the paragraph we want to redo.
            // This is the number of paragraphs from that chapter already in the history, minus one.
            const paragraphIndexToGoTo = history.chapterIndices.filter(i => i === chapterOfLastParagraph).length - 1;

            // 3. Get the raw stats for the paragraph to be "undone".
            const lastWordCount = history.paragraphWordCounts[history.paragraphWordCounts.length - 1];
            const lastTime = history.rawTimes[history.rawTimes.length - 1];
            const lastCorrectChars = history.rawCorrectChars[history.rawCorrectChars.length - 1];
            const lastTypedChars = history.rawTypedChars[history.rawTypedChars.length - 1];

            // 4. Pop all data for the last paragraph from history.
            history.wpm.pop();
            history.accuracy.pop();
            history.labels.pop();
            history.overallWpmHistory.pop();
            history.cumulativeWords.pop();
            history.chapterIndices.pop();
            history.paragraphWordCounts.pop();
            history.cumulativeWordsInChapter.pop();
            history.rawTimes.pop();
            history.rawCorrectChars.pop();
            history.rawTypedChars.pop();

            // 5. Decrement overall stats.
            overallStats.totalTime -= lastTime;
            overallStats.totalCorrectChars -= lastCorrectChars;
            overallStats.totalTypedChars -= lastTypedChars;
            overallStats.cumulativeWordCount -= lastWordCount;
            
            // 6. Handle UI and state transition.
            const chapterNeedsReload = currentChapterIndex !== chapterOfLastParagraph;
            currentChapterIndex = chapterOfLastParagraph;
            currentParagraphIndexInChapter = paragraphIndexToGoTo;

            if (chapterNeedsReload) {
                // loadChapter will render the chapter, highlight completed paragraphs, and activate the correct one.
                loadChapter(currentChapterIndex, true);
            } else {
                // If we are in the same chapter, manually reset the styling of the target paragraph.
                const paragraphEl = document.querySelector(`[data-paragraph-index="${currentParagraphIndexInChapter}"]`);
                if (paragraphEl) {
                    paragraphEl.querySelectorAll('.char-span').forEach(span => {
                        span.className = 'char-span untyped';
                    });
                }
                // Then, activate it. This will reset the paragraph's typing state and move the cursor.
                activateNextParagraph(false);
            }

            // 7. Update all stats displays.
            const overallWPM = overallStats.totalTime > 0 ? ((overallStats.totalTypedChars / CHARS_PER_WORD) / (overallStats.totalTime / 60)) : 0;
            const overallAccuracy = overallStats.totalTypedChars > 0 ? Math.round((overallStats.totalCorrectChars / overallStats.totalTypedChars) * 100) : 100;
            overallWpmDisplay.textContent = overallWPM.toFixed(1);
            overallAccuracyDisplay.textContent = `${overallAccuracy}%`;
            
            const paragraphsDone = history.chapterIndices.filter(i => i === currentChapterIndex).length;
            paragraphCountDisplay.textContent = `${paragraphsDone} / ${currentChapterParagraphs.length}`;

            updateChart();
            saveProgress();
        };

		const updateHighlighting = () => {
			const paragraphEl = currentContentEl.querySelector(`[data-paragraph-index="${currentParagraphIndexInChapter}"]`);
			if (!paragraphEl) return;

			const spans = paragraphEl.querySelectorAll('.char-span');
			const sourceText = currentChapterParagraphs[currentParagraphIndexInChapter].text;

			for (let i = 0; i < sourceText.length; i++) {
				if (i < currentUserInput.length) {
					spans[i].className = currentUserInput[i] === sourceText[i] ? 'char-span correct' : 'char-span incorrect-char';
				} else {
					spans[i].className = 'char-span untyped';
				}
			}
		};

		const updateCursor = () => {
			const paragraphEl = currentContentEl.querySelector(`[data-paragraph-index="${currentParagraphIndexInChapter}"]`);
			if (!paragraphEl) return;

			document.querySelectorAll('.cursor').forEach(el => el.classList.remove('cursor'));

			const spans = paragraphEl.querySelectorAll('.char-span');
			const cursorPosition = currentUserInput.length;

			if (cursorPosition < spans.length) {
				const cursorSpan = spans[cursorPosition];
				cursorSpan.classList.add('cursor');

				const container = currentContentEl;
				const containerRect = container.getBoundingClientRect();
				const cursorRect = cursorSpan.getBoundingClientRect();

				const containerMidpoint = containerRect.top + (containerRect.height / 2);

				if (cursorRect.top > containerMidpoint) {
					const scrollOffset = cursorRect.top - containerMidpoint;
					const newScrollTop = container.scrollTop + scrollOffset;
					container.scrollTo({
						top: newScrollTop,
						behavior: 'smooth'
					});
				}
			} else {
				const endTarget = paragraphEl.querySelector('.end-cursor-target');
				if (endTarget) endTarget.classList.add('cursor');
			}
		};

        // --- CHART LOGIC ---
        const getChapterColor = (chapterIndex) => {
            const hue = (chapterIndex * 40) % 360;
            return `hsla(${hue}, 60%, 50%, 0.6)`;
        };

        const initializeChart = () => {
            const ctx = document.getElementById('history-chart').getContext('2d');
            if (historyChart) {
                historyChart.destroy();
            }
            historyChart = new Chart(ctx, {
                data: { labels: [], datasets: [{ type: 'bar', label: 'Paragraph WPM', data: [], yAxisID: 'y' }] },
                options: {
                    responsive: true,
                    interaction: { mode: 'index', intersect: false },
                    scales: {
                        x: { title: { display: true, text: 'Words Typed', color: '#d1d5db' }, grid: { color: 'rgba(255, 255, 255, 0.1)' }, ticks: { color: '#d1d5db' } },
                        y: { type: 'linear', display: true, position: 'left', title: { display: true, text: 'WPM', color: '#d1d5db' }, grid: { color: 'rgba(255, 255, 255, 0.1)'}, ticks: { color: '#d1d5db' }, beginAtZero: false }
                    },
                    plugins: { 
                        legend: { labels: { color: '#d1d5db' }},
                        tooltip: { callbacks: { label: function(context) {
                            if (isShowingAllHistory) {
                                const chapterIndex = context.dataIndex;
                                const chapterTitle = `Chapter ${chapterIndex + 1}`;
                                const wpm = context.raw;
                                return `${chapterTitle}: ${Math.round(wpm)} WPM Avg`;
                            }
                            const paragraphIndex = context.dataIndex;
                            const wpm = history.wpm[paragraphIndex];
                            const accuracy = history.accuracy[paragraphIndex];
                            return `Paragraph ${paragraphIndex + 1}: ${wpm.toFixed(1)} WPM, ${accuracy}% Accuracy`;
                        }}}
                    }
                }
            });
        };

        const updateChart = () => {
            if (!historyChart) return;

            let dataIndices = [];
            if (isShowingAllHistory) {
                const chapterAggregates = [];
                for (let i = 0; i < chapterMarkers.length; i++) {
                    const chapterHistory = history.wpm.map((wpm, j) => ({ wpm, chapter: history.chapterIndices[j] })).filter(h => h.chapter === i);
                    if (chapterHistory.length > 0) {
                        const avgWpm = chapterHistory.reduce((sum, h) => sum + h.wpm, 0) / chapterHistory.length;
                        chapterAggregates.push(avgWpm);
                    } else {
                        chapterAggregates.push(0);
                    }
                }
                historyChart.data.labels = chapterMarkers.map((cm, i) => `Chapter ${i + 1}`);
                historyChart.data.datasets[0].data = chapterAggregates;
                historyChart.data.datasets[0].backgroundColor = chapterMarkers.map((_, i) => getChapterColor(i));
                historyChart.data.datasets[0].label = 'Chapter WPM';
                historyChart.options.scales.x.type = 'category';
                historyChart.options.scales.x.title.text = 'Chapters';
                dataIndices = chapterAggregates.map((_, i) => i);

            } else {
                for (let i = 0; i < history.chapterIndices.length; i++) {
                    if (history.chapterIndices[i] === currentChapterIndex) {
                        dataIndices.push(i);
                    }
                }
                const barData = dataIndices.map(i => ({ x: history.cumulativeWordsInChapter[i], y: history.wpm[i] }));
                historyChart.data.datasets[0].data = barData;
                historyChart.data.datasets[0].backgroundColor = '#60a5fa'; // Light blue for bars
                historyChart.data.datasets[0].label = 'Paragraph WPM';
                historyChart.options.scales.x.type = 'linear';
                historyChart.options.scales.x.title.text = 'Words Typed in Chapter';

                historyChart.options.scales.x.min = 0;
                historyChart.options.scales.x.max = currentChapterWordCount;
            }

            const allWpms = isShowingAllHistory ? historyChart.data.datasets[0].data.filter(w => w > 0) : history.wpm.filter((_, i) => dataIndices.includes(i));
            if (allWpms.length > 0) {
                const maxWpm = Math.max(...allWpms);
                historyChart.options.scales.y.min = 0;
                historyChart.options.scales.y.max = Math.ceil(maxWpm * 1.20);
            } else {
                historyChart.options.scales.y.min = 0;
                historyChart.options.scales.y.max = 100;
            }

            historyChart.update();
        };

        function wrapCharsInSpans(htmlString) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlString;

            function wrapNode(node) {
                if (node.nodeType === Node.TEXT_NODE) {
                    const text = node.textContent;
                    const fragment = document.createDocumentFragment();
                    for (const char of text) {
                        const span = document.createElement('span');
                        span.className = 'char-span untyped';
                        span.textContent = char;
                        fragment.appendChild(span);
                    }
                    node.parentNode.replaceChild(fragment, node);
                } else if (node.nodeType === Node.ELEMENT_NODE) {
                    const children = Array.from(node.childNodes);
                    children.forEach(wrapNode);
                }
            }

            wrapNode(tempDiv);
            return tempDiv.innerHTML;
        }

        // --- EVENT LISTENERS ---
        document.addEventListener('DOMContentLoaded', setupUser);
        changeUserBtn.addEventListener('click', () => { showLibraryView(); showProfileSwitcher(); });

        // Profile Creation Listeners
        saveProfileBtn.addEventListener('click', saveNewProfile);
        if (cancelCreateProfileBtn) {
            cancelCreateProfileBtn.addEventListener('click', () => {
                profileModal.classList.add('hidden');
                if (getProfiles().length > 0) {
                    showProfileSwitcher();
                }
            });
        }
        
        // Profile Switcher Listeners
        profileSwitcherModal.addEventListener('click', (e) => {
            const loadBtn = e.target.closest('.load-profile-btn');
            const deleteBtn = e.target.closest('.delete-profile-btn');
            if (loadBtn) { loadProfile(loadBtn.dataset.username); }
            if (deleteBtn) { deleteProfile(deleteBtn.dataset.username); }
        });
        showCreateProfileBtn.addEventListener('click', () => {
            profileSwitcherModal.classList.add('hidden');
            profileModal.classList.remove('hidden');
        });
        
        // Book Adding and Chapter Selection Listeners
        addNewBookBtn.addEventListener('click', showFileLoaderView);
        backToLibraryBtn.addEventListener('click', showLibraryView);
        localFileInput.addEventListener('change', (e) => { if (e.target.files.length > 0) handleFile(e.target.files[0]); });
        cancelAddBookBtn.addEventListener('click', () => { tempBookData = {}; chapterSelectionModal.classList.add('hidden'); showFileLoaderView(); });

        // Typing View Listeners
        exitToLibraryBtn.addEventListener('click', () => { saveProgress(); showLibraryView(); });
        document.addEventListener('keydown', handleKeyPress);
        chartToggleButton.addEventListener('click', () => { isShowingAllHistory = !isShowingAllHistory; chartToggleButton.textContent = isShowingAllHistory ? 'Show Current Chapter' : 'Show Entire Book'; updateChart(); });
        libraryList.addEventListener('click', (e) => {
            const startBtn = e.target.closest('.start-typing-btn');
            const deleteBtn = e.target.closest('.delete-book-btn');
            if (startBtn) { startTypingBook(getLibrary()[startBtn.dataset.index]); }
            if (deleteBtn) { deleteBook(deleteBtn.dataset.index); }
        }); 

        // --- Drag and Drop Event Listeners ---
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('drag-over');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
            if (e.dataTransfer.files.length > 0) {
                handleFile(e.dataTransfer.files[0]);
            }
        });


        chapterSelector.addEventListener('change', (e) => {
            const newChapterIndex = parseInt(e.target.value);
            if (newChapterIndex !== currentChapterIndex) {
                loadChapter(newChapterIndex);
            }
        });

        libraryList.addEventListener('click', (e) => {
            const startBtn = e.target.closest('.start-typing-btn');
            const deleteBtn = e.target.closest('.delete-book-btn');

            if (startBtn) {
                const index = startBtn.dataset.index;
                const library = getLibrary();
                startTypingBook(library[index]);
            }
            if (deleteBtn) {
                const index = deleteBtn.dataset.index;
                deleteBook(index);
            }
        });

        chapterListContainer.addEventListener('click', (e) => {
            if (e.target.classList.contains('choice-btn')) {
                const choice = e.target.dataset.choice;
                const buttonGroup = e.target.parentElement;
                
                buttonGroup.querySelectorAll('.choice-btn').forEach(btn => {
                    btn.classList.remove('bg-green-600', 'bg-yellow-600', 'bg-red-600', 'choice-btn-active');
                    btn.classList.add('bg-gray-500', 'hover:bg-gray-600');
                });

                e.target.classList.remove('bg-gray-500', 'hover:bg-gray-600');
                e.target.classList.add('choice-btn-active');
                if (choice === 'type') e.target.classList.add('bg-green-600');
                if (choice === 'skip') e.target.classList.add('bg-yellow-600');
            }
        });

        saveChaptersBtn.addEventListener('click', () => {
            const choices = [];
            chapterListContainer.querySelectorAll('.flex.space-x-2').forEach(group => {
                const index = group.dataset.index;
                const activeButton = group.querySelector('.choice-btn-active');
                const status = activeButton ? activeButton.dataset.choice : 'type';
                choices[index] = { status };
            });

            const newBook = {
                bookName: tempBookData.title,
                author: tempBookData.author,
                cover: tempBookData.cover,
                identifier: tempBookData.identifier,
                chapterMarkers: tempBookData.chapterMarkers,
                userChapterChoices: choices
            };

            const library = getLibrary();
            library.push(newBook);
            saveLibrary(library);

            tempBookData = {};
            chapterSelectionModal.classList.add('hidden');
            showLibraryView();
            renderLibrary();
        });
        
        cancelAddBookBtn.addEventListener('click', () => {
            tempBookData = {};
            chapterSelectionModal.classList.add('hidden');
            showFileLoaderView();
        });

        settingsBtn.addEventListener('click', () => {
            populateSettingsModal();
            settingsModal.classList.remove('hidden');
        });

        closeSettingsBtn.addEventListener('click', () => {
            settingsModal.classList.add('hidden');
        });

		analysisBtn.addEventListener('click', () => {
			displayAnalysis();
			analysisModal.classList.remove('hidden');
		});

		closeAnalysisBtn.addEventListener('click', () => {
			analysisModal.classList.add('hidden');
		});

		drillWeaknessesBtn.addEventListener('click', () => {
			startDrill();
		});

		// Add listeners for the new buttons in the drill view
		endDrillBtn.addEventListener('click', () => {
			isDrillActive = false;
			currentContentEl = bookContentEl;
			drillModeSection.classList.add('hidden');
			drillModeSection.classList.remove('flex');
			showTypingView();
			chapterSelectorContainer.classList.remove('hidden');

			// Just tell the app to resume the chapter you were on
			loadChapter(currentChapterIndex, true);
		});

		drillMoreBtn.addEventListener('click', () => {
			// This will generate a new set of 50 words
			startDrill();
		});

    </script>
	<footer class="text-center py-8 text-sm text-gray-500">
        <a href="https://asilver.github.io/Typing_Tomes/" target="_blank" rel="noopener noreferrer" 
       class="hover:text-indigo-400 transition-colors">
        View on GitHub
        </a>
        <span class="mx-2">|</span>
        <span>
        Released under the <a href="https://github.com/asilver/Typing_Tomes/blob/main/LICENSE" target="_blank" rel="noopener noreferrer" class="underline hover:text-indigo-400 transition-colors">MIT License</a>.
        </span>
    </footer>
</body>
</html>
